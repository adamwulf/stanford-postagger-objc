//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/ling/tokensregex/PhraseTable.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/io/IOUtils.h"
#include "edu/stanford/nlp/ling/CoreAnnotations.h"
#include "edu/stanford/nlp/ling/CoreLabel.h"
#include "edu/stanford/nlp/ling/tokensregex/PhraseTable.h"
#include "edu/stanford/nlp/pipeline/Annotation.h"
#include "edu/stanford/nlp/pipeline/Annotator.h"
#include "edu/stanford/nlp/stats/ClassicCounter.h"
#include "edu/stanford/nlp/stats/Counter.h"
#include "edu/stanford/nlp/util/AbstractIterator.h"
#include "edu/stanford/nlp/util/CacheMap.h"
#include "edu/stanford/nlp/util/Comparators.h"
#include "edu/stanford/nlp/util/CoreMap.h"
#include "edu/stanford/nlp/util/HasInterval.h"
#include "edu/stanford/nlp/util/Interner.h"
#include "edu/stanford/nlp/util/Interval.h"
#include "edu/stanford/nlp/util/IntervalTree.h"
#include "edu/stanford/nlp/util/MapFactory.h"
#include "edu/stanford/nlp/util/StringUtils.h"
#include "edu/stanford/nlp/util/Timing.h"
#include "java/io/BufferedReader.h"
#include "java/io/PrintStream.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Iterable.h"
#include "java/lang/Math.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Comparator.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/Spliterator.h"
#include "java/util/Stack.h"
#include "java/util/function/Consumer.h"
#include "java/util/function/Predicate.h"
#include "java/util/regex/Matcher.h"
#include "java/util/regex/Pattern.h"
#include "java/util/stream/Stream.h"

@interface EduStanfordNlpLingTokensregexPhraseTable () {
 @public
  jint MAX_LIST_SIZE_;
}

- (jboolean)addPhraseWithNSString:(NSString *)phraseText
                     withNSString:(NSString *)tag
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList
                           withId:(id)phraseData;

- (void)addPhraseWithJavaUtilMap:(id<JavaUtilMap>)tree
withEduStanfordNlpLingTokensregexPhraseTable_Phrase:(EduStanfordNlpLingTokensregexPhraseTable_Phrase *)phrase
                         withInt:(jint)wordIndex;

- (jboolean)addPhraseWithJavaUtilMap:(id<JavaUtilMap>)tree
                        withNSString:(NSString *)phraseText
                        withNSString:(NSString *)tag
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList
                              withId:(id)phraseData
                             withInt:(jint)wordIndex;

- (NSString *)createNormalizedFormWithNSString:(NSString *)word;

@end

inline NSString *EduStanfordNlpLingTokensregexPhraseTable_get_PHRASE_END();
static NSString *EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END = @"";
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpLingTokensregexPhraseTable, PHRASE_END, NSString *)

inline jlong EduStanfordNlpLingTokensregexPhraseTable_get_serialVersionUID();
#define EduStanfordNlpLingTokensregexPhraseTable_serialVersionUID 1LL
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpLingTokensregexPhraseTable, serialVersionUID, jlong)

inline JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_get_tabPattern();
static JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_tabPattern;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpLingTokensregexPhraseTable, tabPattern, JavaUtilRegexPattern *)

inline JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_get_punctWhitespacePattern();
static JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_punctWhitespacePattern;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpLingTokensregexPhraseTable, punctWhitespacePattern, JavaUtilRegexPattern *)

inline JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_get_whitespacePattern();
static JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_whitespacePattern;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpLingTokensregexPhraseTable, whitespacePattern, JavaUtilRegexPattern *)

inline JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_get_delimPattern();
static JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_delimPattern;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpLingTokensregexPhraseTable, delimPattern, JavaUtilRegexPattern *)

inline JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_get_possPattern();
static JavaUtilRegexPattern *EduStanfordNlpLingTokensregexPhraseTable_possPattern;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpLingTokensregexPhraseTable, possPattern, JavaUtilRegexPattern *)

__attribute__((unused)) static jboolean EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_(EduStanfordNlpLingTokensregexPhraseTable *self, NSString *phraseText, NSString *tag, id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, id phraseData);

__attribute__((unused)) static void EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_(EduStanfordNlpLingTokensregexPhraseTable *self, id<JavaUtilMap> tree, EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase, jint wordIndex);

__attribute__((unused)) static jboolean EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_withInt_(EduStanfordNlpLingTokensregexPhraseTable *self, id<JavaUtilMap> tree, NSString *phraseText, NSString *tag, id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, id phraseData, jint wordIndex);

__attribute__((unused)) static NSString *EduStanfordNlpLingTokensregexPhraseTable_createNormalizedFormWithNSString_(EduStanfordNlpLingTokensregexPhraseTable *self, NSString *word);

@interface EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator : EduStanfordNlpUtilAbstractIterator {
 @public
  EduStanfordNlpLingTokensregexPhraseTable *phraseTable_;
  JavaUtilStack *iteratorStack_;
  EduStanfordNlpLingTokensregexPhraseTable_Phrase *next_;
}

- (instancetype)initWithEduStanfordNlpLingTokensregexPhraseTable:(EduStanfordNlpLingTokensregexPhraseTable *)phraseTable;

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)getNext;

- (jboolean)hasNext;

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)next;

@end

J2OBJC_EMPTY_STATIC_INIT(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator)

J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator, phraseTable_, EduStanfordNlpLingTokensregexPhraseTable *)
J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator, iteratorStack_, JavaUtilStack *)
J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator, next_, EduStanfordNlpLingTokensregexPhraseTable_Phrase *)

__attribute__((unused)) static void EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *self, EduStanfordNlpLingTokensregexPhraseTable *phraseTable);

__attribute__((unused)) static EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *new_EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(EduStanfordNlpLingTokensregexPhraseTable *phraseTable) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *create_EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(EduStanfordNlpLingTokensregexPhraseTable *phraseTable);

__attribute__((unused)) static EduStanfordNlpLingTokensregexPhraseTable_Phrase *EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_getNext(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *self);

J2OBJC_TYPE_LITERAL_HEADER(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator)

@interface EduStanfordNlpLingTokensregexPhraseTable_StackEntry : NSObject {
 @public
  id<JavaUtilMap> tree_;
  jint tokenStart_;
  jint tokenNext_;
  jint tokenEnd_;
  jint continueAt_;
}

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)tree
                            withInt:(jint)tokenStart
                            withInt:(jint)tokenNext
                            withInt:(jint)tokenEnd
                            withInt:(jint)continueAt;

@end

J2OBJC_EMPTY_STATIC_INIT(EduStanfordNlpLingTokensregexPhraseTable_StackEntry)

J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_StackEntry, tree_, id<JavaUtilMap>)

__attribute__((unused)) static void EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(EduStanfordNlpLingTokensregexPhraseTable_StackEntry *self, id<JavaUtilMap> tree, jint tokenStart, jint tokenNext, jint tokenEnd, jint continueAt);

__attribute__((unused)) static EduStanfordNlpLingTokensregexPhraseTable_StackEntry *new_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(id<JavaUtilMap> tree, jint tokenStart, jint tokenNext, jint tokenEnd, jint continueAt) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpLingTokensregexPhraseTable_StackEntry *create_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(id<JavaUtilMap> tree, jint tokenStart, jint tokenNext, jint tokenEnd, jint continueAt);

J2OBJC_TYPE_LITERAL_HEADER(EduStanfordNlpLingTokensregexPhraseTable_StackEntry)

@interface EduStanfordNlpLingTokensregexPhraseTable_Phrase () {
 @public
  id<JavaUtilSet> alternateForms_;
}

@end

J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_Phrase, alternateForms_, id<JavaUtilSet>)

@interface EduStanfordNlpLingTokensregexPhraseTable_WordList : NSObject

@end

@interface EduStanfordNlpLingTokensregexPhraseTable_TokenList () {
 @public
  id<JavaUtilList> tokens_;
  IOSClass *textKey_;
}

@end

J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_TokenList, tokens_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_TokenList, textKey_, IOSClass *)

@interface EduStanfordNlpLingTokensregexPhraseTable_StringList () {
 @public
  id<JavaUtilList> words_;
}

@end

J2OBJC_FIELD_SETTER(EduStanfordNlpLingTokensregexPhraseTable_StringList, words_, id<JavaUtilList>)

J2OBJC_INITIALIZED_DEFN(EduStanfordNlpLingTokensregexPhraseTable)

id<JavaUtilComparator> EduStanfordNlpLingTokensregexPhraseTable_PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR;

@implementation EduStanfordNlpLingTokensregexPhraseTable

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpLingTokensregexPhraseTable_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithInt:(jint)initSize {
  EduStanfordNlpLingTokensregexPhraseTable_initWithInt_(self, initSize);
  return self;
}

- (instancetype)initWithBoolean:(jboolean)normalize
                    withBoolean:(jboolean)caseInsensitive
                    withBoolean:(jboolean)ignorePunctuation {
  EduStanfordNlpLingTokensregexPhraseTable_initWithBoolean_withBoolean_withBoolean_(self, normalize, caseInsensitive, ignorePunctuation);
  return self;
}

- (jboolean)isEmpty {
  return nPhrases_ == 0;
}

- (jboolean)containsKeyWithId:(id)key {
  return [self getWithId:key] != nil;
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)getWithId:(id)key {
  if ([key isKindOfClass:[NSString class]]) {
    return [self lookupWithNSString:(NSString *) cast_chk(key, [NSString class])];
  }
  else if ([EduStanfordNlpLingTokensregexPhraseTable_WordList_class_() isInstance:key]) {
    return [self lookupWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) cast_check(key, EduStanfordNlpLingTokensregexPhraseTable_WordList_class_())];
  }
  else {
    return nil;
  }
}

- (void)clear {
  rootTree_ = nil;
  nPhrases_ = 0;
  nStrings_ = 0;
}

- (void)setNormalizationCacheSizeWithInt:(jint)cacheSize {
  EduStanfordNlpUtilCacheMap *newNormalizedCache = new_EduStanfordNlpUtilCacheMap_initWithInt_(cacheSize);
  [newNormalizedCache putAllWithJavaUtilMap:normalizedCache_];
  normalizedCache_ = newNormalizedCache;
}

- (void)readPhrasesWithNSString:(NSString *)filename
                    withBoolean:(jboolean)checkTag {
  [self readPhrasesWithNSString:filename withBoolean:checkTag withJavaUtilRegexPattern:EduStanfordNlpLingTokensregexPhraseTable_tabPattern];
}

- (void)readPhrasesWithNSString:(NSString *)filename
                    withBoolean:(jboolean)checkTag
                   withNSString:(NSString *)delimiterRegex {
  [self readPhrasesWithNSString:filename withBoolean:checkTag withJavaUtilRegexPattern:JavaUtilRegexPattern_compileWithNSString_(delimiterRegex)];
}

- (void)readPhrasesWithNSString:(NSString *)filename
                    withBoolean:(jboolean)checkTag
       withJavaUtilRegexPattern:(JavaUtilRegexPattern *)delimiterPattern {
  EduStanfordNlpUtilTiming *timer = new_EduStanfordNlpUtilTiming_init();
  [timer doingWithNSString:JreStrcat("$$", @"Reading phrases: ", filename)];
  JavaIoBufferedReader *br = EduStanfordNlpIoIOUtils_getBufferedFileReaderWithNSString_(filename);
  NSString *line;
  while ((line = [((JavaIoBufferedReader *) nil_chk(br)) readLine]) != nil) {
    if (checkTag) {
      IOSObjectArray *columns = [((JavaUtilRegexPattern *) nil_chk(delimiterPattern)) splitWithJavaLangCharSequence:line withInt:2];
      if (((IOSObjectArray *) nil_chk(columns))->size_ == 1) {
        [self addPhraseWithNSString:IOSObjectArray_Get(columns, 0)];
      }
      else {
        [self addPhraseWithNSString:IOSObjectArray_Get(columns, 0) withNSString:IOSObjectArray_Get(columns, 1)];
      }
    }
    else {
      [self addPhraseWithNSString:line];
    }
  }
  [br close];
  [timer done];
}

- (void)readPhrasesWithTagScoresWithNSString:(NSString *)filename {
  [self readPhrasesWithTagScoresWithNSString:filename withJavaUtilRegexPattern:EduStanfordNlpLingTokensregexPhraseTable_tabPattern withJavaUtilRegexPattern:EduStanfordNlpLingTokensregexPhraseTable_whitespacePattern];
}

- (void)readPhrasesWithTagScoresWithNSString:(NSString *)filename
                                withNSString:(NSString *)fieldDelimiterRegex
                                withNSString:(NSString *)countDelimiterRegex {
  [self readPhrasesWithTagScoresWithNSString:filename withJavaUtilRegexPattern:JavaUtilRegexPattern_compileWithNSString_(fieldDelimiterRegex) withJavaUtilRegexPattern:JavaUtilRegexPattern_compileWithNSString_(countDelimiterRegex)];
}

- (void)readPhrasesWithTagScoresWithNSString:(NSString *)filename
                    withJavaUtilRegexPattern:(JavaUtilRegexPattern *)fieldDelimiterPattern
                    withJavaUtilRegexPattern:(JavaUtilRegexPattern *)countDelimiterPattern {
  EduStanfordNlpUtilTiming *timer = new_EduStanfordNlpUtilTiming_init();
  [timer doingWithNSString:JreStrcat("$$", @"Reading phrases: ", filename)];
  JavaIoBufferedReader *br = EduStanfordNlpIoIOUtils_getBufferedFileReaderWithNSString_(filename);
  NSString *line;
  jint lineno = 0;
  while ((line = [((JavaIoBufferedReader *) nil_chk(br)) readLine]) != nil) {
    IOSObjectArray *columns = [((JavaUtilRegexPattern *) nil_chk(fieldDelimiterPattern)) splitWithJavaLangCharSequence:line];
    NSString *phrase = IOSObjectArray_Get(nil_chk(columns), 0);
    EduStanfordNlpUtilMapFactory *mapFactory = (columns->size_ < 20) ? EduStanfordNlpUtilMapFactory_arrayMapFactory() : EduStanfordNlpUtilMapFactory_linkedHashMapFactory();
    id<EduStanfordNlpStatsCounter> counts = new_EduStanfordNlpStatsClassicCounter_initWithEduStanfordNlpUtilMapFactory_(mapFactory);
    for (jint i = 1; i < columns->size_; i++) {
      IOSObjectArray *tagCount = [((JavaUtilRegexPattern *) nil_chk(countDelimiterPattern)) splitWithJavaLangCharSequence:IOSObjectArray_Get(columns, i) withInt:2];
      if (((IOSObjectArray *) nil_chk(tagCount))->size_ == 2) {
        @try {
          [counts setCountWithId:IOSObjectArray_Get(tagCount, 0) withDouble:JavaLangDouble_parseDoubleWithNSString_(IOSObjectArray_Get(tagCount, 1))];
        }
        @catch (JavaLangNumberFormatException *ex) {
          @throw new_JavaLangRuntimeException_initWithNSString_withNSException_(JreStrcat("$I$$$$CI$$", @"Error processing field ", i, @": '", IOSObjectArray_Get(columns, i), @"' from (", filename, ':', lineno, @"): ", line), ex);
        }
      }
      else {
        @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$I$$$$CI$$", @"Error processing field ", i, @": '", IOSObjectArray_Get(columns, i), @"' from + (", filename, ':', lineno, @"): ", line));
      }
    }
    [self addPhraseWithNSString:phrase withNSString:nil withId:counts];
    lineno++;
  }
  [br close];
  [timer done];
}

- (void)readPhrasesWithNSString:(NSString *)filename
                        withInt:(jint)phraseColIndex
                        withInt:(jint)tagColIndex {
  if (phraseColIndex < 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Invalid phraseColIndex ", phraseColIndex));
  }
  EduStanfordNlpUtilTiming *timer = new_EduStanfordNlpUtilTiming_init();
  [timer doingWithNSString:JreStrcat("$$", @"Reading phrases: ", filename)];
  JavaIoBufferedReader *br = EduStanfordNlpIoIOUtils_getBufferedFileReaderWithNSString_(filename);
  NSString *line;
  while ((line = [((JavaIoBufferedReader *) nil_chk(br)) readLine]) != nil) {
    IOSObjectArray *columns = [((JavaUtilRegexPattern *) nil_chk(EduStanfordNlpLingTokensregexPhraseTable_tabPattern)) splitWithJavaLangCharSequence:line];
    NSString *phrase = IOSObjectArray_Get(nil_chk(columns), phraseColIndex);
    NSString *tag = (tagColIndex >= 0) ? IOSObjectArray_Get(columns, tagColIndex) : nil;
    [self addPhraseWithNSString:phrase withNSString:tag];
  }
  [br close];
  [timer done];
}

+ (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)getLongestPhraseWithJavaUtilList:(id<JavaUtilList>)phrases {
  return EduStanfordNlpLingTokensregexPhraseTable_getLongestPhraseWithJavaUtilList_(phrases);
}

- (IOSObjectArray *)splitTextWithNSString:(NSString *)phraseText {
  IOSObjectArray *words;
  if (tokenizer_ != nil) {
    EduStanfordNlpPipelineAnnotation *annotation = new_EduStanfordNlpPipelineAnnotation_initWithNSString_(phraseText);
    [((id<EduStanfordNlpPipelineAnnotator>) nil_chk(tokenizer_)) annotateWithEduStanfordNlpPipelineAnnotation:annotation];
    id<JavaUtilList> tokens = [annotation getWithIOSClass:EduStanfordNlpLingCoreAnnotations_TokensAnnotation_class_()];
    words = [IOSObjectArray newArrayWithLength:[((id<JavaUtilList>) nil_chk(tokens)) size] type:NSString_class_()];
    for (jint i = 0; i < [tokens size]; i++) {
      (void) IOSObjectArray_Set(words, i, [((EduStanfordNlpLingCoreLabel *) nil_chk([tokens getWithInt:i])) word]);
    }
  }
  else {
    phraseText = [((JavaUtilRegexMatcher *) nil_chk([((JavaUtilRegexPattern *) nil_chk(EduStanfordNlpLingTokensregexPhraseTable_possPattern)) matcherWithJavaLangCharSequence:phraseText])) replaceAllWithNSString:@" 's$1"];
    words = [((JavaUtilRegexPattern *) nil_chk(EduStanfordNlpLingTokensregexPhraseTable_delimPattern)) splitWithJavaLangCharSequence:phraseText];
  }
  return words;
}

- (id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)toWordListWithNSString:(NSString *)phraseText {
  IOSObjectArray *words = [self splitTextWithNSString:phraseText];
  return new_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithNSStringArray_(words);
}

- (id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)toNormalizedWordListWithNSString:(NSString *)phraseText {
  IOSObjectArray *words = [self splitTextWithNSString:phraseText];
  id<JavaUtilList> list = new_JavaUtilArrayList_initWithInt_(((IOSObjectArray *) nil_chk(words))->size_);
  {
    IOSObjectArray *a__ = words;
    NSString * const *b__ = a__->buffer_;
    NSString * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      NSString *word = *b__++;
      word = [self getNormalizedFormWithNSString:word];
      if (((jint) [((NSString *) nil_chk(word)) length]) > 0) {
        [list addWithId:word];
      }
    }
  }
  return new_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(list);
}

- (void)addPhrasesWithJavaUtilCollection:(id<JavaUtilCollection>)phraseTexts {
  for (NSString * __strong phraseText in nil_chk(phraseTexts)) {
    [self addPhraseWithNSString:phraseText withNSString:nil];
  }
}

- (void)addPhrasesWithJavaUtilMap:(id<JavaUtilMap>)taggedPhraseTexts {
  for (NSString * __strong phraseText in nil_chk([((id<JavaUtilMap>) nil_chk(taggedPhraseTexts)) keySet])) {
    [self addPhraseWithNSString:phraseText withNSString:[taggedPhraseTexts getWithId:phraseText]];
  }
}

- (jboolean)addPhraseWithNSString:(NSString *)phraseText {
  return [self addPhraseWithNSString:phraseText withNSString:nil];
}

- (jboolean)addPhraseWithNSString:(NSString *)phraseText
                     withNSString:(NSString *)tag {
  return [self addPhraseWithNSString:phraseText withNSString:tag withId:nil];
}

- (jboolean)addPhraseWithNSString:(NSString *)phraseText
                     withNSString:(NSString *)tag
                           withId:(id)phraseData {
  id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList = [self toNormalizedWordListWithNSString:phraseText];
  return EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_(self, phraseText, tag, wordList, phraseData);
}

- (jboolean)addPhraseWithJavaUtilList:(id<JavaUtilList>)tokens {
  return [self addPhraseWithJavaUtilList:tokens withNSString:nil];
}

- (jboolean)addPhraseWithJavaUtilList:(id<JavaUtilList>)tokens
                         withNSString:(NSString *)tag {
  return [self addPhraseWithJavaUtilList:tokens withNSString:tag withId:nil];
}

- (jboolean)addPhraseWithJavaUtilList:(id<JavaUtilList>)tokens
                         withNSString:(NSString *)tag
                               withId:(id)phraseData {
  id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList = new_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(tokens);
  return EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_(self, EduStanfordNlpUtilStringUtils_joinWithJavaLangIterable_withNSString_(tokens, @" "), tag, wordList, phraseData);
}

- (jboolean)addPhraseWithNSString:(NSString *)phraseText
                     withNSString:(NSString *)tag
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList
                           withId:(id)phraseData {
  return EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_(self, phraseText, tag, wordList, phraseData);
}

- (void)addPhraseWithJavaUtilMap:(id<JavaUtilMap>)tree
withEduStanfordNlpLingTokensregexPhraseTable_Phrase:(EduStanfordNlpLingTokensregexPhraseTable_Phrase *)phrase
                         withInt:(jint)wordIndex {
  EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_(self, tree, phrase, wordIndex);
}

- (jboolean)addPhraseWithJavaUtilMap:(id<JavaUtilMap>)tree
                        withNSString:(NSString *)phraseText
                        withNSString:(NSString *)tag
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList
                              withId:(id)phraseData
                             withInt:(jint)wordIndex {
  return EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_withInt_(self, tree, phraseText, tag, wordList, phraseData, wordIndex);
}

- (NSString *)getNormalizedFormWithNSString:(NSString *)word {
  NSString *normalized = [((EduStanfordNlpUtilCacheMap *) nil_chk(normalizedCache_)) getWithId:word];
  if (normalized == nil) {
    normalized = EduStanfordNlpLingTokensregexPhraseTable_createNormalizedFormWithNSString_(self, word);
    @synchronized(self) {
      (void) [((EduStanfordNlpUtilCacheMap *) nil_chk(normalizedCache_)) putWithId:word withId:normalized];
    }
  }
  return normalized;
}

- (NSString *)createNormalizedFormWithNSString:(NSString *)word {
  return EduStanfordNlpLingTokensregexPhraseTable_createNormalizedFormWithNSString_(self, word);
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)lookupWithNSString:(NSString *)phrase {
  return [self lookupWithEduStanfordNlpLingTokensregexPhraseTable_WordList:[self toWordListWithNSString:phrase]];
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)lookupNormalizedWithNSString:(NSString *)phrase {
  return [self lookupWithEduStanfordNlpLingTokensregexPhraseTable_WordList:[self toNormalizedWordListWithNSString:phrase]];
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)lookupWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList {
  if (wordList == nil || rootTree_ == nil) return nil;
  id<JavaUtilMap> tree = rootTree_;
  for (jint i = 0; i < [wordList size]; i++) {
    NSString *word = [wordList getWordWithInt:i];
    id node = [tree getWithId:word];
    if (node == nil) {
      return nil;
    }
    else if ([node isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
      EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(node, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
      jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:phrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:wordList withInt:0 withInt:[wordList size] withInt:i withBoolean:true];
      if (matchedTokenEnd >= 0) {
        return phrase;
      }
    }
    else if ([JavaUtilMap_class_() isInstance:node]) {
      tree = (id<JavaUtilMap>) cast_check(node, JavaUtilMap_class_());
    }
    else if ([JavaUtilList_class_() isInstance:node]) {
      id<JavaUtilList> lookupList = (id<JavaUtilList>) cast_check(node, JavaUtilList_class_());
      jint nMaps = 0;
      for (id __strong obj in lookupList) {
        if ([obj isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
          EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(obj, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
          jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:phrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:wordList withInt:0 withInt:[wordList size] withInt:i withBoolean:true];
          if (matchedTokenEnd >= 0) {
            return phrase;
          }
        }
        else if ([JavaUtilMap_class_() isInstance:obj]) {
          if (nMaps == 1) {
            @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$IC$$$", @"More than one map in list while looking up word ", i, '(', word, @") in phrase ", [wordList description]));
          }
          tree = (id<JavaUtilMap>) cast_check(obj, JavaUtilMap_class_());
          nMaps++;
        }
        else {
          @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$IC$$$", @"Unexpected class in list ", [nil_chk(obj) getClass], @" while looking up word ", i, '(', word, @") in phrase ", [wordList description]));
        }
      }
      if (nMaps == 0) {
        return nil;
      }
    }
    else {
      @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$IC$$$", @"Unexpected class in list ", [node getClass], @" while looking up word ", i, '(', word, @") in phrase ", [wordList description]));
    }
  }
  EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk([tree getWithId:EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END], [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
  if (phrase != nil) {
    jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:phrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:wordList withInt:0 withInt:[wordList size] withInt:[wordList size] withBoolean:true];
    return (matchedTokenEnd >= 0) ? phrase : nil;
  }
  else {
    return nil;
  }
}

- (id<JavaUtilList>)findAllMatchesWithNSString:(NSString *)text {
  id<EduStanfordNlpLingTokensregexPhraseTable_WordList> tokens = [self toNormalizedWordListWithNSString:text];
  return [self findAllMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:0 withInt:[((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) size] withBoolean:false];
}

- (id<JavaUtilList>)findAllMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens {
  return [self findAllMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:0 withInt:[((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) size] withBoolean:true];
}

- (id<JavaUtilList>)findAllMatchesWithJavaUtilList:(id<JavaUtilList>)acceptablePhrases
                                      withNSString:(NSString *)text {
  id<EduStanfordNlpLingTokensregexPhraseTable_WordList> tokens = [self toNormalizedWordListWithNSString:text];
  return [self findAllMatchesWithJavaUtilList:acceptablePhrases withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:0 withInt:[((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) size] withBoolean:false];
}

- (id<JavaUtilList>)findAllMatchesWithJavaUtilList:(id<JavaUtilList>)acceptablePhrases
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens {
  return [self findAllMatchesWithJavaUtilList:acceptablePhrases withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:0 withInt:[((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) size] withBoolean:true];
}

- (id<JavaUtilList>)findAllMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens
                                                                                withInt:(jint)tokenStart
                                                                                withInt:(jint)tokenEnd
                                                                            withBoolean:(jboolean)needNormalization {
  return [self findMatchesWithJavaUtilCollection:nil withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:tokenStart withInt:tokenEnd withBoolean:needNormalization withBoolean:true withBoolean:false];
}

- (id<JavaUtilList>)findAllMatchesWithJavaUtilList:(id<JavaUtilList>)acceptablePhrases
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens
                                           withInt:(jint)tokenStart
                                           withInt:(jint)tokenEnd
                                       withBoolean:(jboolean)needNormalization {
  return [self findMatchesWithJavaUtilCollection:acceptablePhrases withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:tokenStart withInt:tokenEnd withBoolean:needNormalization withBoolean:true withBoolean:false];
}

- (id<JavaUtilList>)findMatchesWithNSString:(NSString *)text {
  id<EduStanfordNlpLingTokensregexPhraseTable_WordList> tokens = [self toNormalizedWordListWithNSString:text];
  return [self findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:0 withInt:[((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) size] withBoolean:false];
}

- (id<JavaUtilList>)findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens {
  return [self findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:0 withInt:[((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) size] withBoolean:true];
}

- (id<JavaUtilList>)findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens
                                                                             withInt:(jint)tokenStart
                                                                             withInt:(jint)tokenEnd
                                                                         withBoolean:(jboolean)needNormalization {
  return [self findMatchesWithJavaUtilCollection:nil withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:tokenStart withInt:tokenEnd withBoolean:needNormalization withBoolean:false withBoolean:false];
}

- (id<JavaUtilList>)findMatchesWithNSString:(NSString *)text
                                    withInt:(jint)tokenStart
                                    withInt:(jint)tokenEnd
                                withBoolean:(jboolean)needNormalization {
  id<EduStanfordNlpLingTokensregexPhraseTable_WordList> tokens = [self toNormalizedWordListWithNSString:text];
  return [self findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:tokenStart withInt:tokenEnd withBoolean:false];
}

- (jint)checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:(EduStanfordNlpLingTokensregexPhraseTable_Phrase *)phrase
                        withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens
                                                                      withInt:(jint)tokenStart
                                                                      withInt:(jint)tokenEnd
                                                                      withInt:(jint)checkStart
                                                                  withBoolean:(jboolean)matchEnd {
  if (checkStart < tokenStart) return -1;
  jint i;
  jint phraseSize = [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(((EduStanfordNlpLingTokensregexPhraseTable_Phrase *) nil_chk(phrase))->wordList_)) size];
  for (i = checkStart; i < tokenEnd && i - tokenStart < phraseSize; i++) {
    NSString *word = [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) getWordWithInt:i];
    NSString *phraseWord = [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(phrase->wordList_)) getWordWithInt:i - tokenStart];
    if (![((NSString *) nil_chk(phraseWord)) isEqual:word]) {
      return -1;
    }
  }
  if (i - tokenStart == phraseSize) {
    if (matchEnd) {
      return (i == tokenEnd) ? i : -1;
    }
    else {
      return i;
    }
  }
  else {
    return -1;
  }
}

- (id<JavaUtilList>)findNonOverlappingPhrasesWithJavaUtilList:(id<JavaUtilList>)phraseMatches {
  if ([((id<JavaUtilList>) nil_chk(phraseMatches)) size] > 1) {
    return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilComparator_(phraseMatches, EduStanfordNlpLingTokensregexPhraseTable_PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR);
  }
  else {
    return phraseMatches;
  }
}

- (id<JavaUtilList>)findMatchesWithJavaUtilCollection:(id<JavaUtilCollection>)acceptablePhrases
withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens
                                              withInt:(jint)tokenStart
                                              withInt:(jint)tokenEnd
                                          withBoolean:(jboolean)needNormalization
                                          withBoolean:(jboolean)findAll
                                          withBoolean:(jboolean)matchEnd {
  if (needNormalization) {
    JreAssert(((tokenStart >= 0)), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:727 condition failed: assert(tokenStart >= 0);"));
    JreAssert(((tokenEnd > tokenStart)), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:728 condition failed: assert(tokenEnd > tokenStart);"));
    jint n = tokenEnd - tokenStart;
    id<JavaUtilList> normalized = new_JavaUtilArrayList_initWithInt_(n);
    IOSIntArray *tokenIndexMap = [IOSIntArray newArrayWithLength:n + 1];
    jint j = 0, last = 0;
    for (jint i = tokenStart; i < tokenEnd; i++) {
      NSString *word = [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) getWordWithInt:i];
      word = [self getNormalizedFormWithNSString:word];
      if (((jint) [((NSString *) nil_chk(word)) length]) != 0) {
        [normalized addWithId:word];
        *IOSIntArray_GetRef(tokenIndexMap, j) = i;
        last = i;
        j++;
      }
    }
    *IOSIntArray_GetRef(tokenIndexMap, j) = JavaLangMath_minWithInt_withInt_(last + 1, tokenEnd);
    id<JavaUtilList> matched = [self findMatchesNormalizedWithJavaUtilCollection:acceptablePhrases withEduStanfordNlpLingTokensregexPhraseTable_WordList:new_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(normalized) withInt:0 withInt:[normalized size] withBoolean:findAll withBoolean:matchEnd];
    for (EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch * __strong pm in nil_chk(matched)) {
      JreAssert(((((EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch *) nil_chk(pm))->tokenBegin_ >= 0)), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:747 condition failed: assert(pm.tokenBegin >= 0);"));
      JreAssert(((pm->tokenEnd_ >= pm->tokenBegin_)), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:748 condition failed: assert(pm.tokenEnd >= pm.tokenBegin);"));
      JreAssert(((pm->tokenEnd_ <= [normalized size])), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:749 condition failed: assert(pm.tokenEnd <= normalized.size());"));
      if (pm->tokenEnd_ > 0 && pm->tokenEnd_ > pm->tokenBegin_) {
        pm->tokenEnd_ = IOSIntArray_Get(tokenIndexMap, pm->tokenEnd_ - 1) + 1;
      }
      else {
        pm->tokenEnd_ = IOSIntArray_Get(tokenIndexMap, pm->tokenEnd_);
      }
      pm->tokenBegin_ = IOSIntArray_Get(tokenIndexMap, pm->tokenBegin_);
      JreAssert(((pm->tokenBegin_ >= 0)), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:756 condition failed: assert(pm.tokenBegin >= 0);"));
      JreAssert(((pm->tokenEnd_ >= pm->tokenBegin_)), (@"edu/stanford/nlp/ling/tokensregex/PhraseTable.java:757 condition failed: assert(pm.tokenEnd >= pm.tokenBegin);"));
    }
    return matched;
  }
  else {
    return [self findMatchesNormalizedWithJavaUtilCollection:acceptablePhrases withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:tokenStart withInt:tokenEnd withBoolean:findAll withBoolean:matchEnd];
  }
}

- (id<JavaUtilList>)findMatchesNormalizedWithJavaUtilCollection:(id<JavaUtilCollection>)acceptablePhrases
          withEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)tokens
                                                        withInt:(jint)tokenStart
                                                        withInt:(jint)tokenEnd
                                                    withBoolean:(jboolean)findAll
                                                    withBoolean:(jboolean)matchEnd {
  id<JavaUtilList> matched = new_JavaUtilArrayList_init();
  JavaUtilStack *todoStack = new_JavaUtilStack_init();
  (void) [todoStack pushWithId:new_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(rootTree_, tokenStart, tokenStart, tokenEnd, findAll ? tokenStart + 1 : -1)];
  while (![todoStack isEmpty]) {
    EduStanfordNlpLingTokensregexPhraseTable_StackEntry *cur = [todoStack pop];
    id<JavaUtilMap> tree = ((EduStanfordNlpLingTokensregexPhraseTable_StackEntry *) nil_chk(cur))->tree_;
    for (jint i = cur->tokenNext_; i <= cur->tokenEnd_; i++) {
      if ([((id<JavaUtilMap>) nil_chk(tree)) containsKeyWithId:EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END]) {
        EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk([tree getWithId:EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END], [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
        if (acceptablePhrases == nil || [acceptablePhrases containsWithId:phrase]) {
          jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:phrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:cur->tokenStart_ withInt:cur->tokenEnd_ withInt:i withBoolean:matchEnd];
          if (matchedTokenEnd >= 0) {
            [matched addWithId:new_EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(phrase, cur->tokenStart_, matchedTokenEnd)];
          }
        }
      }
      if (i == cur->tokenEnd_) break;
      NSString *word = [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(tokens)) getWordWithInt:i];
      id node = [tree getWithId:word];
      if (node == nil) {
        break;
      }
      else if ([node isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
        EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(node, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
        if (acceptablePhrases == nil || [acceptablePhrases containsWithId:phrase]) {
          jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:phrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:cur->tokenStart_ withInt:cur->tokenEnd_ withInt:i + 1 withBoolean:matchEnd];
          if (matchedTokenEnd >= 0) {
            [matched addWithId:new_EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(phrase, cur->tokenStart_, matchedTokenEnd)];
          }
        }
        break;
      }
      else if ([JavaUtilMap_class_() isInstance:node]) {
        tree = (id<JavaUtilMap>) cast_check(node, JavaUtilMap_class_());
      }
      else if ([JavaUtilList_class_() isInstance:node]) {
        id<JavaUtilList> lookupList = (id<JavaUtilList>) cast_check(node, JavaUtilList_class_());
        for (id __strong obj in lookupList) {
          if ([obj isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
            EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(obj, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
            if (acceptablePhrases == nil || [acceptablePhrases containsWithId:phrase]) {
              jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:phrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:tokens withInt:cur->tokenStart_ withInt:cur->tokenEnd_ withInt:i + 1 withBoolean:matchEnd];
              if (matchedTokenEnd >= 0) {
                [matched addWithId:new_EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(phrase, cur->tokenStart_, matchedTokenEnd)];
              }
            }
          }
          else if ([JavaUtilMap_class_() isInstance:obj]) {
            (void) [todoStack pushWithId:new_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_((id<JavaUtilMap>) cast_check(obj, JavaUtilMap_class_()), cur->tokenStart_, i + 1, cur->tokenEnd_, -1)];
          }
          else {
            @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$$", @"Unexpected class in list ", [nil_chk(obj) getClass], @" while looking up ", word));
          }
        }
        break;
      }
      else {
        @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$$", @"Unexpected class ", [node getClass], @" while looking up ", word));
      }
    }
    if (cur->continueAt_ >= 0) {
      jint newStart = (cur->continueAt_ > cur->tokenStart_) ? cur->continueAt_ : cur->tokenStart_ + 1;
      if (newStart < cur->tokenEnd_) {
        (void) [todoStack pushWithId:new_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(cur->tree_, newStart, newStart, cur->tokenEnd_, newStart + 1)];
      }
    }
  }
  return matched;
}

- (id<JavaUtilIterator>)iterator {
  return new_EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(self);
}

+ (NSString *)toStringWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList {
  return EduStanfordNlpLingTokensregexPhraseTable_toStringWithEduStanfordNlpLingTokensregexPhraseTable_WordList_(wordList);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x1, 4, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 9, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 10, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 13, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 14, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 15, 8, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x9, 16, 17, -1, 18, -1, -1 },
    { NULL, "[LNSString;", 0x1, 19, 12, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_WordList;", 0x1, 20, 12, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_WordList;", 0x1, 21, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 22, 23, -1, 24, -1, -1 },
    { NULL, "V", 0x1, 22, 25, -1, 26, -1, -1 },
    { NULL, "Z", 0x1, 27, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 27, 28, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 27, 29, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 27, 17, -1, 30, -1, -1 },
    { NULL, "Z", 0x1, 27, 31, -1, 32, -1, -1 },
    { NULL, "Z", 0x1, 27, 33, -1, 34, -1, -1 },
    { NULL, "Z", 0x22, 27, 35, -1, -1, -1, -1 },
    { NULL, "V", 0x22, 27, 36, -1, 37, -1, -1 },
    { NULL, "Z", 0x22, 27, 38, -1, 39, -1, -1 },
    { NULL, "LNSString;", 0x1, 40, 12, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 41, 12, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x1, 42, 12, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x1, 43, 12, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x1, 42, 44, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 45, 12, -1, 46, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 45, 44, -1, 47, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 45, 31, -1, 48, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 45, 49, -1, 50, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 45, 51, -1, 52, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 45, 53, -1, 54, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 55, 12, -1, 46, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 55, 44, -1, 47, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 55, 51, -1, 52, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 55, 56, -1, 57, -1, -1 },
    { NULL, "I", 0x4, 58, 59, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 60, 17, -1, 61, -1, -1 },
    { NULL, "LJavaUtilList;", 0x4, 55, 62, -1, 63, -1, -1 },
    { NULL, "LJavaUtilList;", 0x4, 64, 65, -1, 66, -1, -1 },
    { NULL, "LJavaUtilIterator;", 0x1, -1, -1, -1, 67, -1, -1 },
    { NULL, "LNSString;", 0x9, 68, 44, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithInt:);
  methods[2].selector = @selector(initWithBoolean:withBoolean:withBoolean:);
  methods[3].selector = @selector(isEmpty);
  methods[4].selector = @selector(containsKeyWithId:);
  methods[5].selector = @selector(getWithId:);
  methods[6].selector = @selector(clear);
  methods[7].selector = @selector(setNormalizationCacheSizeWithInt:);
  methods[8].selector = @selector(readPhrasesWithNSString:withBoolean:);
  methods[9].selector = @selector(readPhrasesWithNSString:withBoolean:withNSString:);
  methods[10].selector = @selector(readPhrasesWithNSString:withBoolean:withJavaUtilRegexPattern:);
  methods[11].selector = @selector(readPhrasesWithTagScoresWithNSString:);
  methods[12].selector = @selector(readPhrasesWithTagScoresWithNSString:withNSString:withNSString:);
  methods[13].selector = @selector(readPhrasesWithTagScoresWithNSString:withJavaUtilRegexPattern:withJavaUtilRegexPattern:);
  methods[14].selector = @selector(readPhrasesWithNSString:withInt:withInt:);
  methods[15].selector = @selector(getLongestPhraseWithJavaUtilList:);
  methods[16].selector = @selector(splitTextWithNSString:);
  methods[17].selector = @selector(toWordListWithNSString:);
  methods[18].selector = @selector(toNormalizedWordListWithNSString:);
  methods[19].selector = @selector(addPhrasesWithJavaUtilCollection:);
  methods[20].selector = @selector(addPhrasesWithJavaUtilMap:);
  methods[21].selector = @selector(addPhraseWithNSString:);
  methods[22].selector = @selector(addPhraseWithNSString:withNSString:);
  methods[23].selector = @selector(addPhraseWithNSString:withNSString:withId:);
  methods[24].selector = @selector(addPhraseWithJavaUtilList:);
  methods[25].selector = @selector(addPhraseWithJavaUtilList:withNSString:);
  methods[26].selector = @selector(addPhraseWithJavaUtilList:withNSString:withId:);
  methods[27].selector = @selector(addPhraseWithNSString:withNSString:withEduStanfordNlpLingTokensregexPhraseTable_WordList:withId:);
  methods[28].selector = @selector(addPhraseWithJavaUtilMap:withEduStanfordNlpLingTokensregexPhraseTable_Phrase:withInt:);
  methods[29].selector = @selector(addPhraseWithJavaUtilMap:withNSString:withNSString:withEduStanfordNlpLingTokensregexPhraseTable_WordList:withId:withInt:);
  methods[30].selector = @selector(getNormalizedFormWithNSString:);
  methods[31].selector = @selector(createNormalizedFormWithNSString:);
  methods[32].selector = @selector(lookupWithNSString:);
  methods[33].selector = @selector(lookupNormalizedWithNSString:);
  methods[34].selector = @selector(lookupWithEduStanfordNlpLingTokensregexPhraseTable_WordList:);
  methods[35].selector = @selector(findAllMatchesWithNSString:);
  methods[36].selector = @selector(findAllMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:);
  methods[37].selector = @selector(findAllMatchesWithJavaUtilList:withNSString:);
  methods[38].selector = @selector(findAllMatchesWithJavaUtilList:withEduStanfordNlpLingTokensregexPhraseTable_WordList:);
  methods[39].selector = @selector(findAllMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:withInt:withInt:withBoolean:);
  methods[40].selector = @selector(findAllMatchesWithJavaUtilList:withEduStanfordNlpLingTokensregexPhraseTable_WordList:withInt:withInt:withBoolean:);
  methods[41].selector = @selector(findMatchesWithNSString:);
  methods[42].selector = @selector(findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:);
  methods[43].selector = @selector(findMatchesWithEduStanfordNlpLingTokensregexPhraseTable_WordList:withInt:withInt:withBoolean:);
  methods[44].selector = @selector(findMatchesWithNSString:withInt:withInt:withBoolean:);
  methods[45].selector = @selector(checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:withEduStanfordNlpLingTokensregexPhraseTable_WordList:withInt:withInt:withInt:withBoolean:);
  methods[46].selector = @selector(findNonOverlappingPhrasesWithJavaUtilList:);
  methods[47].selector = @selector(findMatchesWithJavaUtilCollection:withEduStanfordNlpLingTokensregexPhraseTable_WordList:withInt:withInt:withBoolean:withBoolean:withBoolean:);
  methods[48].selector = @selector(findMatchesNormalizedWithJavaUtilCollection:withEduStanfordNlpLingTokensregexPhraseTable_WordList:withInt:withInt:withBoolean:withBoolean:);
  methods[49].selector = @selector(iterator);
  methods[50].selector = @selector(toStringWithEduStanfordNlpLingTokensregexPhraseTable_WordList:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "PHRASE_END", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 69, -1, -1 },
    { "serialVersionUID", "J", .constantValue.asLong = EduStanfordNlpLingTokensregexPhraseTable_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "rootTree_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x0, -1, -1, 70, -1 },
    { "normalize_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "caseInsensitive_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "ignorePunctuation_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "ignorePunctuationTokens_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "tokenizer_", "LEduStanfordNlpPipelineAnnotator;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "nPhrases_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "nStrings_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "normalizedCache_", "LEduStanfordNlpUtilCacheMap;", .constantValue.asLong = 0, 0x80, -1, -1, 71, -1 },
    { "tabPattern", "LJavaUtilRegexPattern;", .constantValue.asLong = 0, 0x1a, -1, 72, -1, -1 },
    { "MAX_LIST_SIZE_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "punctWhitespacePattern", "LJavaUtilRegexPattern;", .constantValue.asLong = 0, 0x1a, -1, 73, -1, -1 },
    { "whitespacePattern", "LJavaUtilRegexPattern;", .constantValue.asLong = 0, 0x1a, -1, 74, -1, -1 },
    { "delimPattern", "LJavaUtilRegexPattern;", .constantValue.asLong = 0, 0x1a, -1, 75, -1, -1 },
    { "possPattern", "LJavaUtilRegexPattern;", .constantValue.asLong = 0, 0x1a, -1, 76, -1, -1 },
    { "PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR", "LJavaUtilComparator;", .constantValue.asLong = 0, 0x19, -1, 77, 78, -1 },
  };
  static const void *ptrTable[] = { "I", "ZZZ", "containsKey", "LNSObject;", "get", "setNormalizationCacheSize", "readPhrases", "LNSString;Z", "LJavaIoIOException;", "LNSString;ZLNSString;", "LNSString;ZLJavaUtilRegexPattern;", "readPhrasesWithTagScores", "LNSString;", "LNSString;LNSString;LNSString;", "LNSString;LJavaUtilRegexPattern;LJavaUtilRegexPattern;", "LNSString;II", "getLongestPhrase", "LJavaUtilList;", "(Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;)Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;", "splitText", "toWordList", "toNormalizedWordList", "addPhrases", "LJavaUtilCollection;", "(Ljava/util/Collection<Ljava/lang/String;>;)V", "LJavaUtilMap;", "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V", "addPhrase", "LNSString;LNSString;", "LNSString;LNSString;LNSObject;", "(Ljava/util/List<Ljava/lang/String;>;)Z", "LJavaUtilList;LNSString;", "(Ljava/util/List<Ljava/lang/String;>;Ljava/lang/String;)Z", "LJavaUtilList;LNSString;LNSObject;", "(Ljava/util/List<Ljava/lang/String;>;Ljava/lang/String;Ljava/lang/Object;)Z", "LNSString;LNSString;LEduStanfordNlpLingTokensregexPhraseTable_WordList;LNSObject;", "LJavaUtilMap;LEduStanfordNlpLingTokensregexPhraseTable_Phrase;I", "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;I)V", "LJavaUtilMap;LNSString;LNSString;LEduStanfordNlpLingTokensregexPhraseTable_WordList;LNSObject;I", "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;Ljava/lang/String;Ljava/lang/String;Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;Ljava/lang/Object;I)Z", "getNormalizedForm", "createNormalizedForm", "lookup", "lookupNormalized", "LEduStanfordNlpLingTokensregexPhraseTable_WordList;", "findAllMatches", "(Ljava/lang/String;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "(Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "(Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;Ljava/lang/String;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "LJavaUtilList;LEduStanfordNlpLingTokensregexPhraseTable_WordList;", "(Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "LEduStanfordNlpLingTokensregexPhraseTable_WordList;IIZ", "(Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;IIZ)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "LJavaUtilList;LEduStanfordNlpLingTokensregexPhraseTable_WordList;IIZ", "(Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;IIZ)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "findMatches", "LNSString;IIZ", "(Ljava/lang/String;IIZ)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "checkWordListMatch", "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;LEduStanfordNlpLingTokensregexPhraseTable_WordList;IIIZ", "findNonOverlappingPhrases", "(Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "LJavaUtilCollection;LEduStanfordNlpLingTokensregexPhraseTable_WordList;IIZZZ", "(Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;IIZZZ)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "findMatchesNormalized", "LJavaUtilCollection;LEduStanfordNlpLingTokensregexPhraseTable_WordList;IIZZ", "(Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;Ledu/stanford/nlp/ling/tokensregex/PhraseTable$WordList;IIZZ)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "()Ljava/util/Iterator<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;", "toString", &EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END, "Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;", "Ledu/stanford/nlp/util/CacheMap<Ljava/lang/String;Ljava/lang/String;>;", &EduStanfordNlpLingTokensregexPhraseTable_tabPattern, &EduStanfordNlpLingTokensregexPhraseTable_punctWhitespacePattern, &EduStanfordNlpLingTokensregexPhraseTable_whitespacePattern, &EduStanfordNlpLingTokensregexPhraseTable_delimPattern, &EduStanfordNlpLingTokensregexPhraseTable_possPattern, &EduStanfordNlpLingTokensregexPhraseTable_PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR, "Ljava/util/Comparator<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$PhraseMatch;>;", "LEduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator;LEduStanfordNlpLingTokensregexPhraseTable_StackEntry;LEduStanfordNlpLingTokensregexPhraseTable_Phrase;LEduStanfordNlpLingTokensregexPhraseTable_PhraseMatch;LEduStanfordNlpLingTokensregexPhraseTable_WordList;LEduStanfordNlpLingTokensregexPhraseTable_TokenList;LEduStanfordNlpLingTokensregexPhraseTable_StringList;LEduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable = { "PhraseTable", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x1, 51, 18, -1, 79, -1, -1, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable;
}

+ (void)initialize {
  if (self == [EduStanfordNlpLingTokensregexPhraseTable class]) {
    EduStanfordNlpLingTokensregexPhraseTable_tabPattern = JavaUtilRegexPattern_compileWithNSString_(@"\t");
    EduStanfordNlpLingTokensregexPhraseTable_punctWhitespacePattern = JavaUtilRegexPattern_compileWithNSString_(@"\\s*(\\p{Punct})\\s*");
    EduStanfordNlpLingTokensregexPhraseTable_whitespacePattern = JavaUtilRegexPattern_compileWithNSString_(@"\\s+");
    EduStanfordNlpLingTokensregexPhraseTable_delimPattern = JavaUtilRegexPattern_compileWithNSString_(@"[\\s_-]+");
    EduStanfordNlpLingTokensregexPhraseTable_possPattern = JavaUtilRegexPattern_compileWithNSString_(@"'s(\\s+|$)");
    EduStanfordNlpLingTokensregexPhraseTable_PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR = EduStanfordNlpUtilComparators_chainWithJavaUtilComparator_withJavaUtilComparator_(JreLoadStatic(EduStanfordNlpUtilHasInterval, LENGTH_GT_COMPARATOR), JreLoadStatic(EduStanfordNlpUtilHasInterval, ENDPOINTS_COMPARATOR));
    J2OBJC_SET_INITIALIZED(EduStanfordNlpLingTokensregexPhraseTable)
  }
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_init(EduStanfordNlpLingTokensregexPhraseTable *self) {
  NSObject_init(self);
  self->normalize_ = true;
  self->caseInsensitive_ = false;
  self->ignorePunctuation_ = false;
  self->ignorePunctuationTokens_ = true;
  self->nPhrases_ = 0;
  self->nStrings_ = 0;
  self->normalizedCache_ = new_EduStanfordNlpUtilCacheMap_initWithInt_(5000);
  self->MAX_LIST_SIZE_ = 20;
}

EduStanfordNlpLingTokensregexPhraseTable *new_EduStanfordNlpLingTokensregexPhraseTable_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable, init)
}

EduStanfordNlpLingTokensregexPhraseTable *create_EduStanfordNlpLingTokensregexPhraseTable_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable, init)
}

void EduStanfordNlpLingTokensregexPhraseTable_initWithInt_(EduStanfordNlpLingTokensregexPhraseTable *self, jint initSize) {
  NSObject_init(self);
  self->normalize_ = true;
  self->caseInsensitive_ = false;
  self->ignorePunctuation_ = false;
  self->ignorePunctuationTokens_ = true;
  self->nPhrases_ = 0;
  self->nStrings_ = 0;
  self->normalizedCache_ = new_EduStanfordNlpUtilCacheMap_initWithInt_(5000);
  self->MAX_LIST_SIZE_ = 20;
  self->rootTree_ = new_JavaUtilHashMap_initWithInt_(initSize);
}

EduStanfordNlpLingTokensregexPhraseTable *new_EduStanfordNlpLingTokensregexPhraseTable_initWithInt_(jint initSize) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable, initWithInt_, initSize)
}

EduStanfordNlpLingTokensregexPhraseTable *create_EduStanfordNlpLingTokensregexPhraseTable_initWithInt_(jint initSize) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable, initWithInt_, initSize)
}

void EduStanfordNlpLingTokensregexPhraseTable_initWithBoolean_withBoolean_withBoolean_(EduStanfordNlpLingTokensregexPhraseTable *self, jboolean normalize, jboolean caseInsensitive, jboolean ignorePunctuation) {
  NSObject_init(self);
  self->normalize_ = true;
  self->caseInsensitive_ = false;
  self->ignorePunctuation_ = false;
  self->ignorePunctuationTokens_ = true;
  self->nPhrases_ = 0;
  self->nStrings_ = 0;
  self->normalizedCache_ = new_EduStanfordNlpUtilCacheMap_initWithInt_(5000);
  self->MAX_LIST_SIZE_ = 20;
  self->normalize_ = normalize;
  self->caseInsensitive_ = caseInsensitive;
  self->ignorePunctuation_ = ignorePunctuation;
}

EduStanfordNlpLingTokensregexPhraseTable *new_EduStanfordNlpLingTokensregexPhraseTable_initWithBoolean_withBoolean_withBoolean_(jboolean normalize, jboolean caseInsensitive, jboolean ignorePunctuation) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable, initWithBoolean_withBoolean_withBoolean_, normalize, caseInsensitive, ignorePunctuation)
}

EduStanfordNlpLingTokensregexPhraseTable *create_EduStanfordNlpLingTokensregexPhraseTable_initWithBoolean_withBoolean_withBoolean_(jboolean normalize, jboolean caseInsensitive, jboolean ignorePunctuation) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable, initWithBoolean_withBoolean_withBoolean_, normalize, caseInsensitive, ignorePunctuation)
}

EduStanfordNlpLingTokensregexPhraseTable_Phrase *EduStanfordNlpLingTokensregexPhraseTable_getLongestPhraseWithJavaUtilList_(id<JavaUtilList> phrases) {
  EduStanfordNlpLingTokensregexPhraseTable_initialize();
  EduStanfordNlpLingTokensregexPhraseTable_Phrase *longest = nil;
  for (EduStanfordNlpLingTokensregexPhraseTable_Phrase * __strong phrase in nil_chk(phrases)) {
    if (longest == nil || [((EduStanfordNlpLingTokensregexPhraseTable_Phrase *) nil_chk(phrase)) isLongerWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:longest]) {
      longest = phrase;
    }
  }
  return longest;
}

jboolean EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_(EduStanfordNlpLingTokensregexPhraseTable *self, NSString *phraseText, NSString *tag, id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, id phraseData) {
  @synchronized(self) {
    if (self->rootTree_ == nil) {
      self->rootTree_ = new_JavaUtilHashMap_init();
    }
    return EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_withInt_(self, self->rootTree_, phraseText, tag, wordList, phraseData, 0);
  }
}

void EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_(EduStanfordNlpLingTokensregexPhraseTable *self, id<JavaUtilMap> tree, EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase, jint wordIndex) {
  @synchronized(self) {
    NSString *word = ([((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(((EduStanfordNlpLingTokensregexPhraseTable_Phrase *) nil_chk(phrase))->wordList_)) size] <= wordIndex) ? EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END : [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(phrase->wordList_)) getWordWithInt:wordIndex];
    id node = [((id<JavaUtilMap>) nil_chk(tree)) getWithId:word];
    if (node == nil) {
      (void) [tree putWithId:word withId:phrase];
    }
    else if ([node isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
      id<JavaUtilList> list = new_JavaUtilArrayList_initWithInt_(2);
      [list addWithId:phrase];
      [list addWithId:node];
      (void) [tree putWithId:word withId:list];
    }
    else if ([JavaUtilMap_class_() isInstance:node]) {
      EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_(self, (id<JavaUtilMap>) cast_check(node, JavaUtilMap_class_()), phrase, wordIndex + 1);
    }
    else if ([JavaUtilList_class_() isInstance:node]) {
      [((id<JavaUtilList>) cast_check(node, JavaUtilList_class_())) addWithId:phrase];
    }
    else {
      @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$IC$$$", @"Unexpected class ", [node getClass], @" while adding word ", wordIndex, '(', word, @") in phrase ", [phrase getText]));
    }
  }
}

jboolean EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withNSString_withNSString_withEduStanfordNlpLingTokensregexPhraseTable_WordList_withId_withInt_(EduStanfordNlpLingTokensregexPhraseTable *self, id<JavaUtilMap> tree, NSString *phraseText, NSString *tag, id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, id phraseData, jint wordIndex) {
  @synchronized(self) {
    jboolean phraseAdded = false;
    jboolean newPhraseAdded = false;
    jboolean oldPhraseNewFormAdded = false;
    for (jint i = wordIndex; i < [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(wordList)) size]; i++) {
      NSString *word = EduStanfordNlpUtilInterner_globalInternWithId_([wordList getWordWithInt:i]);
      id node = [((id<JavaUtilMap>) nil_chk(tree)) getWithId:word];
      if (node == nil) {
        EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase = new_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(wordList, phraseText, tag, phraseData);
        (void) [tree putWithId:word withId:phrase];
        phraseAdded = true;
        newPhraseAdded = true;
      }
      else if ([node isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
        EduStanfordNlpLingTokensregexPhraseTable_Phrase *oldphrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(node, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
        jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:oldphrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:wordList withInt:0 withInt:[wordList size] withInt:i + 1 withBoolean:true];
        if (matchedTokenEnd >= 0) {
          oldPhraseNewFormAdded = [oldphrase addFormWithNSString:phraseText];
        }
        else {
          EduStanfordNlpLingTokensregexPhraseTable_Phrase *newphrase = new_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(wordList, phraseText, tag, phraseData);
          id<JavaUtilList> list = new_JavaUtilArrayList_initWithInt_(2);
          [list addWithId:oldphrase];
          [list addWithId:newphrase];
          (void) [tree putWithId:word withId:list];
          newPhraseAdded = true;
        }
        phraseAdded = true;
      }
      else if ([JavaUtilMap_class_() isInstance:node]) {
        tree = (id<JavaUtilMap>) cast_check(node, JavaUtilMap_class_());
      }
      else if ([JavaUtilList_class_() isInstance:node]) {
        id<JavaUtilList> lookupList = (id<JavaUtilList>) cast_check(node, JavaUtilList_class_());
        jint nMaps = 0;
        for (id __strong obj in lookupList) {
          if ([obj isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
            EduStanfordNlpLingTokensregexPhraseTable_Phrase *oldphrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(obj, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
            jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:oldphrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:wordList withInt:0 withInt:[wordList size] withInt:i withBoolean:true];
            if (matchedTokenEnd >= 0) {
              oldPhraseNewFormAdded = [((EduStanfordNlpLingTokensregexPhraseTable_Phrase *) nil_chk(oldphrase)) addFormWithNSString:phraseText];
              phraseAdded = true;
              break;
            }
          }
          else if ([JavaUtilMap_class_() isInstance:obj]) {
            if (nMaps == 1) {
              @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$IC$$$", @"More than one map in list while adding word ", i, '(', word, @") in phrase ", phraseText));
            }
            tree = (id<JavaUtilMap>) cast_check(obj, JavaUtilMap_class_());
            nMaps++;
          }
          else {
            @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$IC$$$", @"Unexpected class in list ", [nil_chk(obj) getClass], @" while adding word ", i, '(', word, @") in phrase ", phraseText));
          }
        }
        if (!phraseAdded && nMaps == 0) {
          EduStanfordNlpLingTokensregexPhraseTable_Phrase *newphrase = new_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(wordList, phraseText, tag, phraseData);
          [lookupList addWithId:newphrase];
          newPhraseAdded = true;
          phraseAdded = true;
          if ([lookupList size] > self->MAX_LIST_SIZE_) {
            id<JavaUtilMap> newMap = new_JavaUtilHashMap_initWithInt_([lookupList size]);
            for (id __strong obj in lookupList) {
              if ([obj isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
                EduStanfordNlpLingTokensregexPhraseTable_Phrase *oldphrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(obj, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
                EduStanfordNlpLingTokensregexPhraseTable_addPhraseWithJavaUtilMap_withEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_(self, newMap, oldphrase, i + 1);
              }
              else {
                @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$", @"Unexpected class in list ", [nil_chk(obj) getClass], @" while converting list to map"));
              }
            }
            (void) [((id<JavaUtilMap>) nil_chk(tree)) putWithId:word withId:newMap];
          }
        }
      }
      else {
        @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$IC$$$", @"Unexpected class in list ", [node getClass], @" while adding word ", i, '(', word, @") in phrase ", phraseText));
      }
      if (phraseAdded) {
        break;
      }
    }
    if (!phraseAdded) {
      if ([wordList size] == 0) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$$", @"WARNING: ", phraseText, @" not added")];
      }
      else {
        EduStanfordNlpLingTokensregexPhraseTable_Phrase *oldphrase = (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk([((id<JavaUtilMap>) nil_chk(tree)) getWithId:EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END], [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
        if (oldphrase != nil) {
          jint matchedTokenEnd = [self checkWordListMatchWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:oldphrase withEduStanfordNlpLingTokensregexPhraseTable_WordList:wordList withInt:0 withInt:[wordList size] withInt:[wordList size] withBoolean:true];
          if (matchedTokenEnd >= 0) {
            oldPhraseNewFormAdded = [oldphrase addFormWithNSString:phraseText];
          }
          else {
            EduStanfordNlpLingTokensregexPhraseTable_Phrase *newphrase = new_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(wordList, phraseText, tag, phraseData);
            id<JavaUtilList> list = new_JavaUtilArrayList_initWithInt_(2);
            [list addWithId:oldphrase];
            [list addWithId:newphrase];
            (void) [tree putWithId:EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END withId:list];
            newPhraseAdded = true;
          }
        }
        else {
          EduStanfordNlpLingTokensregexPhraseTable_Phrase *newphrase = new_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(wordList, phraseText, tag, phraseData);
          (void) [tree putWithId:EduStanfordNlpLingTokensregexPhraseTable_PHRASE_END withId:newphrase];
          newPhraseAdded = true;
        }
      }
    }
    if (newPhraseAdded) {
      self->nPhrases_++;
      self->nStrings_++;
    }
    else {
      self->nStrings_++;
    }
    return (newPhraseAdded || oldPhraseNewFormAdded);
  }
}

NSString *EduStanfordNlpLingTokensregexPhraseTable_createNormalizedFormWithNSString_(EduStanfordNlpLingTokensregexPhraseTable *self, NSString *word) {
  if (self->normalize_) {
    word = EduStanfordNlpUtilStringUtils_normalizeWithNSString_(word);
  }
  if (self->caseInsensitive_) {
    word = [((NSString *) nil_chk(word)) lowercaseString];
  }
  if (self->ignorePunctuation_) {
    word = [((JavaUtilRegexMatcher *) nil_chk([((JavaUtilRegexPattern *) nil_chk(EduStanfordNlpLingTokensregexPhraseTable_punctWhitespacePattern)) matcherWithJavaLangCharSequence:word])) replaceAllWithNSString:@""];
  }
  else if (self->ignorePunctuationTokens_) {
    if ([((JavaUtilRegexMatcher *) nil_chk([((JavaUtilRegexPattern *) nil_chk(EduStanfordNlpLingTokensregexPhraseTable_punctWhitespacePattern)) matcherWithJavaLangCharSequence:word])) matches]) {
      word = @"";
    }
  }
  word = [((JavaUtilRegexMatcher *) nil_chk([((JavaUtilRegexPattern *) nil_chk(EduStanfordNlpLingTokensregexPhraseTable_whitespacePattern)) matcherWithJavaLangCharSequence:word])) replaceAllWithNSString:@""];
  return word;
}

NSString *EduStanfordNlpLingTokensregexPhraseTable_toStringWithEduStanfordNlpLingTokensregexPhraseTable_WordList_(id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList) {
  EduStanfordNlpLingTokensregexPhraseTable_initialize();
  JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
  for (jint i = 0; i < [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk(wordList)) size]; i++) {
    if ([sb length] > 0) {
      (void) [sb appendWithNSString:@" "];
    }
    (void) [sb appendWithNSString:[wordList getWordWithInt:i]];
  }
  return [sb description];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable)

@implementation EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator

- (instancetype)initWithEduStanfordNlpLingTokensregexPhraseTable:(EduStanfordNlpLingTokensregexPhraseTable *)phraseTable {
  EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(self, phraseTable);
  return self;
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)getNext {
  return EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_getNext(self);
}

- (jboolean)hasNext {
  return next_ != nil;
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)next {
  EduStanfordNlpLingTokensregexPhraseTable_Phrase *res = next_;
  next_ = EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_getNext(self);
  return res;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x1, -1, -1, -1, 1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpLingTokensregexPhraseTable:);
  methods[1].selector = @selector(getNext);
  methods[2].selector = @selector(hasNext);
  methods[3].selector = @selector(next);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "phraseTable_", "LEduStanfordNlpLingTokensregexPhraseTable;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "iteratorStack_", "LJavaUtilStack;", .constantValue.asLong = 0, 0x2, -1, -1, 2, -1 },
    { "next_", "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexPhraseTable;", "()Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;", "Ljava/util/Stack<Ljava/util/Iterator<Ljava/lang/Object;>;>;", "Ledu/stanford/nlp/util/AbstractIterator<Ledu/stanford/nlp/ling/tokensregex/PhraseTable$Phrase;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator = { "PhraseTableIterator", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0xa, 4, 3, 0, -1, -1, 3, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *self, EduStanfordNlpLingTokensregexPhraseTable *phraseTable) {
  EduStanfordNlpUtilAbstractIterator_init(self);
  self->iteratorStack_ = new_JavaUtilStack_init();
  self->next_ = nil;
  self->phraseTable_ = phraseTable;
  (void) [self->iteratorStack_ pushWithId:[((id<JavaUtilCollection>) nil_chk([((id<JavaUtilMap>) nil_chk(((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(self->phraseTable_))->rootTree_)) values])) iterator]];
  self->next_ = EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_getNext(self);
}

EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *new_EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(EduStanfordNlpLingTokensregexPhraseTable *phraseTable) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator, initWithEduStanfordNlpLingTokensregexPhraseTable_, phraseTable)
}

EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *create_EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_initWithEduStanfordNlpLingTokensregexPhraseTable_(EduStanfordNlpLingTokensregexPhraseTable *phraseTable) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator, initWithEduStanfordNlpLingTokensregexPhraseTable_, phraseTable)
}

EduStanfordNlpLingTokensregexPhraseTable_Phrase *EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator_getNext(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator *self) {
  while (![((JavaUtilStack *) nil_chk(self->iteratorStack_)) isEmpty]) {
    id<JavaUtilIterator> iter = [((JavaUtilStack *) nil_chk(self->iteratorStack_)) peek];
    if ([((id<JavaUtilIterator>) nil_chk(iter)) hasNext]) {
      id obj = [iter next];
      if ([obj isKindOfClass:[EduStanfordNlpLingTokensregexPhraseTable_Phrase class]]) {
        return (EduStanfordNlpLingTokensregexPhraseTable_Phrase *) cast_chk(obj, [EduStanfordNlpLingTokensregexPhraseTable_Phrase class]);
      }
      else if ([JavaUtilMap_class_() isInstance:obj]) {
        (void) [((JavaUtilStack *) nil_chk(self->iteratorStack_)) pushWithId:[((id<JavaUtilCollection>) nil_chk([((id<JavaUtilMap>) nil_chk(((id<JavaUtilMap>) cast_check(obj, JavaUtilMap_class_())))) values])) iterator]];
      }
      else if ([JavaUtilList_class_() isInstance:obj]) {
        (void) [((JavaUtilStack *) nil_chk(self->iteratorStack_)) pushWithId:[((id<JavaUtilList>) nil_chk(((id<JavaUtilList>) cast_check(obj, JavaUtilList_class_())))) iterator]];
      }
      else {
        @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@", @"Unexpected class in phrase table ", [nil_chk(obj) getClass]));
      }
    }
    else {
      (void) [((JavaUtilStack *) nil_chk(self->iteratorStack_)) pop];
    }
  }
  return nil;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_PhraseTableIterator)

@implementation EduStanfordNlpLingTokensregexPhraseTable_StackEntry

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)tree
                            withInt:(jint)tokenStart
                            withInt:(jint)tokenNext
                            withInt:(jint)tokenEnd
                            withInt:(jint)continueAt {
  EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(self, tree, tokenStart, tokenNext, tokenEnd, continueAt);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, 1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilMap:withInt:withInt:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tree_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x0, -1, -1, 2, -1 },
    { "tokenStart_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tokenNext_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tokenEnd_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "continueAt_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilMap;IIII", "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;IIII)V", "Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;", "LEduStanfordNlpLingTokensregexPhraseTable;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_StackEntry = { "StackEntry", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0xa, 1, 5, 3, -1, -1, -1, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_StackEntry;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(EduStanfordNlpLingTokensregexPhraseTable_StackEntry *self, id<JavaUtilMap> tree, jint tokenStart, jint tokenNext, jint tokenEnd, jint continueAt) {
  NSObject_init(self);
  self->tree_ = tree;
  self->tokenStart_ = tokenStart;
  self->tokenNext_ = tokenNext;
  self->tokenEnd_ = tokenEnd;
  self->continueAt_ = continueAt;
}

EduStanfordNlpLingTokensregexPhraseTable_StackEntry *new_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(id<JavaUtilMap> tree, jint tokenStart, jint tokenNext, jint tokenEnd, jint continueAt) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_StackEntry, initWithJavaUtilMap_withInt_withInt_withInt_withInt_, tree, tokenStart, tokenNext, tokenEnd, continueAt)
}

EduStanfordNlpLingTokensregexPhraseTable_StackEntry *create_EduStanfordNlpLingTokensregexPhraseTable_StackEntry_initWithJavaUtilMap_withInt_withInt_withInt_withInt_(id<JavaUtilMap> tree, jint tokenStart, jint tokenNext, jint tokenEnd, jint continueAt) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_StackEntry, initWithJavaUtilMap_withInt_withInt_withInt_withInt_, tree, tokenStart, tokenNext, tokenEnd, continueAt)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_StackEntry)

@implementation EduStanfordNlpLingTokensregexPhraseTable_Phrase

- (instancetype)initWithEduStanfordNlpLingTokensregexPhraseTable_WordList:(id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)wordList
                                                             withNSString:(NSString *)text
                                                             withNSString:(NSString *)tag
                                                                   withId:(id)data {
  EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(self, wordList, text, tag, data);
  return self;
}

- (jboolean)isLongerWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:(EduStanfordNlpLingTokensregexPhraseTable_Phrase *)phrase {
  return ([((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk([self getWordList])) size] > [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk([((EduStanfordNlpLingTokensregexPhraseTable_Phrase *) nil_chk(phrase)) getWordList])) size] || ([((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk([self getWordList])) size] == [((id<EduStanfordNlpLingTokensregexPhraseTable_WordList>) nil_chk([phrase getWordList])) size] && ((jint) [((NSString *) nil_chk([self getText])) length]) > ((jint) [((NSString *) nil_chk([phrase getText])) length])));
}

- (jboolean)addFormWithNSString:(NSString *)form {
  if (alternateForms_ == nil) {
    alternateForms_ = new_JavaUtilHashSet_initWithInt_(4);
    [alternateForms_ addWithId:text_];
  }
  return [((id<JavaUtilSet>) nil_chk(alternateForms_)) addWithId:form];
}

- (id<EduStanfordNlpLingTokensregexPhraseTable_WordList>)getWordList {
  return wordList_;
}

- (NSString *)getText {
  return text_;
}

- (NSString *)getTag {
  return tag_;
}

- (id)getData {
  return data_;
}

- (id<JavaUtilCollection>)getAlternateForms {
  if (alternateForms_ == nil) {
    id<JavaUtilList> forms = new_JavaUtilArrayList_initWithInt_(1);
    [forms addWithId:text_];
    return forms;
  }
  return alternateForms_;
}

- (NSString *)description {
  return text_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_WordList;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilCollection;", 0x1, -1, -1, -1, 5, -1, -1 },
    { NULL, "LNSString;", 0x1, 6, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpLingTokensregexPhraseTable_WordList:withNSString:withNSString:withId:);
  methods[1].selector = @selector(isLongerWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:);
  methods[2].selector = @selector(addFormWithNSString:);
  methods[3].selector = @selector(getWordList);
  methods[4].selector = @selector(getText);
  methods[5].selector = @selector(getTag);
  methods[6].selector = @selector(getData);
  methods[7].selector = @selector(getAlternateForms);
  methods[8].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "wordList_", "LEduStanfordNlpLingTokensregexPhraseTable_WordList;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "text_", "LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tag_", "LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "data_", "LNSObject;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "alternateForms_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x2, -1, -1, 7, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexPhraseTable_WordList;LNSString;LNSString;LNSObject;", "isLonger", "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", "addForm", "LNSString;", "()Ljava/util/Collection<Ljava/lang/String;>;", "toString", "Ljava/util/Set<Ljava/lang/String;>;", "LEduStanfordNlpLingTokensregexPhraseTable;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_Phrase = { "Phrase", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x9, 9, 5, 8, -1, -1, -1, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_Phrase;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(EduStanfordNlpLingTokensregexPhraseTable_Phrase *self, id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, NSString *text, NSString *tag, id data) {
  NSObject_init(self);
  self->wordList_ = wordList;
  self->text_ = text;
  self->tag_ = tag;
  self->data_ = data;
}

EduStanfordNlpLingTokensregexPhraseTable_Phrase *new_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, NSString *text, NSString *tag, id data) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_Phrase, initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_, wordList, text, tag, data)
}

EduStanfordNlpLingTokensregexPhraseTable_Phrase *create_EduStanfordNlpLingTokensregexPhraseTable_Phrase_initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_(id<EduStanfordNlpLingTokensregexPhraseTable_WordList> wordList, NSString *text, NSString *tag, id data) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_Phrase, initWithEduStanfordNlpLingTokensregexPhraseTable_WordList_withNSString_withNSString_withId_, wordList, text, tag, data)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_Phrase)

@implementation EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch

- (instancetype)initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:(EduStanfordNlpLingTokensregexPhraseTable_Phrase *)phrase
                                                                withInt:(jint)tokenBegin
                                                                withInt:(jint)tokenEnd {
  EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(self, phrase, tokenBegin, tokenEnd);
  return self;
}

- (EduStanfordNlpLingTokensregexPhraseTable_Phrase *)getPhrase {
  return phrase_;
}

- (jint)getTokenBegin {
  return tokenBegin_;
}

- (jint)getTokenEnd {
  return tokenEnd_;
}

- (NSString *)description {
  JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
  (void) [sb appendWithId:phrase_];
  (void) [((JavaLangStringBuilder *) nil_chk([sb appendWithNSString:@" at ("])) appendWithInt:tokenBegin_];
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([sb appendWithNSString:@","])) appendWithInt:tokenEnd_])) appendWithNSString:@")"];
  return [sb description];
}

- (EduStanfordNlpUtilInterval *)getInterval {
  if (span_ == nil) span_ = EduStanfordNlpUtilInterval_toIntervalWithJavaLangComparable_withJavaLangComparable_withInt_(JavaLangInteger_valueOfWithInt_(tokenBegin_), JavaLangInteger_valueOfWithInt_(tokenEnd_), EduStanfordNlpUtilInterval_INTERVAL_OPEN_END);
  return span_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 1, -1, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpUtilInterval;", 0x1, -1, -1, -1, 2, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase:withInt:withInt:);
  methods[1].selector = @selector(getPhrase);
  methods[2].selector = @selector(getTokenBegin);
  methods[3].selector = @selector(getTokenEnd);
  methods[4].selector = @selector(description);
  methods[5].selector = @selector(getInterval);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "phrase_", "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tokenBegin_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tokenEnd_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "span_", "LEduStanfordNlpUtilInterval;", .constantValue.asLong = 0, 0x80, -1, -1, 3, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexPhraseTable_Phrase;II", "toString", "()Ledu/stanford/nlp/util/Interval<Ljava/lang/Integer;>;", "Ledu/stanford/nlp/util/Interval<Ljava/lang/Integer;>;", "LEduStanfordNlpLingTokensregexPhraseTable;", "Ljava/lang/Object;Ledu/stanford/nlp/util/HasInterval<Ljava/lang/Integer;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch = { "PhraseMatch", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x9, 6, 4, 4, -1, -1, 5, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch *self, EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase, jint tokenBegin, jint tokenEnd) {
  NSObject_init(self);
  self->phrase_ = phrase;
  self->tokenBegin_ = tokenBegin;
  self->tokenEnd_ = tokenEnd;
}

EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch *new_EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase, jint tokenBegin, jint tokenEnd) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch, initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_, phrase, tokenBegin, tokenEnd)
}

EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch *create_EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch_initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_(EduStanfordNlpLingTokensregexPhraseTable_Phrase *phrase, jint tokenBegin, jint tokenEnd) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch, initWithEduStanfordNlpLingTokensregexPhraseTable_Phrase_withInt_withInt_, phrase, tokenBegin, tokenEnd)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_PhraseMatch)

@implementation EduStanfordNlpLingTokensregexPhraseTable_WordList

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0x401, 0, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x401, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(getWordWithInt:);
  methods[1].selector = @selector(size);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "getWord", "I", "LEduStanfordNlpLingTokensregexPhraseTable;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_WordList = { "WordList", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, NULL, 7, 0x609, 2, 0, 2, -1, -1, -1, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_WordList;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_WordList)

@implementation EduStanfordNlpLingTokensregexPhraseTable_TokenList

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)tokens {
  EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_(self, tokens);
  return self;
}

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)tokens
                        withIOSClass:(IOSClass *)key {
  EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_withIOSClass_(self, tokens, key);
  return self;
}

- (NSString *)getWordWithInt:(jint)i {
  return (NSString *) cast_chk([((id<EduStanfordNlpUtilCoreMap>) nil_chk([((id<JavaUtilList>) nil_chk(tokens_)) getWithInt:i])) getWithIOSClass:textKey_], [NSString class]);
}

- (jint)size {
  return [((id<JavaUtilList>) nil_chk(tokens_)) size];
}

- (NSString *)description {
  return EduStanfordNlpLingTokensregexPhraseTable_toStringWithEduStanfordNlpLingTokensregexPhraseTable_WordList_(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, 3, -1, -1 },
    { NULL, "LNSString;", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 6, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilList:);
  methods[1].selector = @selector(initWithJavaUtilList:withIOSClass:);
  methods[2].selector = @selector(getWordWithInt:);
  methods[3].selector = @selector(size);
  methods[4].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tokens_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 7, -1 },
    { "textKey_", "LIOSClass;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilList;", "(Ljava/util/List<Ledu/stanford/nlp/ling/CoreLabel;>;)V", "LJavaUtilList;LIOSClass;", "(Ljava/util/List<+Ledu/stanford/nlp/util/CoreMap;>;Ljava/lang/Class;)V", "getWord", "I", "toString", "Ljava/util/List<+Ledu/stanford/nlp/util/CoreMap;>;", "LEduStanfordNlpLingTokensregexPhraseTable;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_TokenList = { "TokenList", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x9, 5, 2, 8, -1, -1, -1, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_TokenList;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_(EduStanfordNlpLingTokensregexPhraseTable_TokenList *self, id<JavaUtilList> tokens) {
  NSObject_init(self);
  self->textKey_ = EduStanfordNlpLingCoreAnnotations_TextAnnotation_class_();
  self->tokens_ = tokens;
}

EduStanfordNlpLingTokensregexPhraseTable_TokenList *new_EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_(id<JavaUtilList> tokens) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_TokenList, initWithJavaUtilList_, tokens)
}

EduStanfordNlpLingTokensregexPhraseTable_TokenList *create_EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_(id<JavaUtilList> tokens) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_TokenList, initWithJavaUtilList_, tokens)
}

void EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_withIOSClass_(EduStanfordNlpLingTokensregexPhraseTable_TokenList *self, id<JavaUtilList> tokens, IOSClass *key) {
  NSObject_init(self);
  self->textKey_ = EduStanfordNlpLingCoreAnnotations_TextAnnotation_class_();
  self->tokens_ = tokens;
  self->textKey_ = key;
}

EduStanfordNlpLingTokensregexPhraseTable_TokenList *new_EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_withIOSClass_(id<JavaUtilList> tokens, IOSClass *key) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_TokenList, initWithJavaUtilList_withIOSClass_, tokens, key)
}

EduStanfordNlpLingTokensregexPhraseTable_TokenList *create_EduStanfordNlpLingTokensregexPhraseTable_TokenList_initWithJavaUtilList_withIOSClass_(id<JavaUtilList> tokens, IOSClass *key) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_TokenList, initWithJavaUtilList_withIOSClass_, tokens, key)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_TokenList)

@implementation EduStanfordNlpLingTokensregexPhraseTable_StringList

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)words {
  EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(self, words);
  return self;
}

- (instancetype)initWithNSStringArray:(IOSObjectArray *)wordsArray {
  EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithNSStringArray_(self, wordsArray);
  return self;
}

- (NSString *)getWordWithInt:(jint)i {
  return [((id<JavaUtilList>) nil_chk(words_)) getWithInt:i];
}

- (jint)size {
  return [((id<JavaUtilList>) nil_chk(words_)) size];
}

- (NSString *)description {
  return EduStanfordNlpLingTokensregexPhraseTable_toStringWithEduStanfordNlpLingTokensregexPhraseTable_WordList_(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 5, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilList:);
  methods[1].selector = @selector(initWithNSStringArray:);
  methods[2].selector = @selector(getWordWithInt:);
  methods[3].selector = @selector(size);
  methods[4].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "words_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 6, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilList;", "(Ljava/util/List<Ljava/lang/String;>;)V", "[LNSString;", "getWord", "I", "toString", "Ljava/util/List<Ljava/lang/String;>;", "LEduStanfordNlpLingTokensregexPhraseTable;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_StringList = { "StringList", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x9, 5, 1, 7, -1, -1, -1, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_StringList;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(EduStanfordNlpLingTokensregexPhraseTable_StringList *self, id<JavaUtilList> words) {
  NSObject_init(self);
  self->words_ = words;
}

EduStanfordNlpLingTokensregexPhraseTable_StringList *new_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(id<JavaUtilList> words) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_StringList, initWithJavaUtilList_, words)
}

EduStanfordNlpLingTokensregexPhraseTable_StringList *create_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithJavaUtilList_(id<JavaUtilList> words) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_StringList, initWithJavaUtilList_, words)
}

void EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithNSStringArray_(EduStanfordNlpLingTokensregexPhraseTable_StringList *self, IOSObjectArray *wordsArray) {
  NSObject_init(self);
  self->words_ = JavaUtilArrays_asListWithNSObjectArray_(wordsArray);
}

EduStanfordNlpLingTokensregexPhraseTable_StringList *new_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithNSStringArray_(IOSObjectArray *wordsArray) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_StringList, initWithNSStringArray_, wordsArray)
}

EduStanfordNlpLingTokensregexPhraseTable_StringList *create_EduStanfordNlpLingTokensregexPhraseTable_StringList_initWithNSStringArray_(IOSObjectArray *wordsArray) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_StringList, initWithNSStringArray_, wordsArray)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_StringList)

@implementation EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection

- (instancetype)initWithEduStanfordNlpLingTokensregexPhraseTable:(EduStanfordNlpLingTokensregexPhraseTable *)phraseTable
                                                     withBoolean:(jboolean)useNormalizedLookup {
  EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection_initWithEduStanfordNlpLingTokensregexPhraseTable_withBoolean_(self, phraseTable, useNormalizedLookup);
  return self;
}

- (jint)size {
  return ((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(phraseTable_))->nStrings_;
}

- (jboolean)isEmpty {
  return ((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(phraseTable_))->nStrings_ == 0;
}

- (jboolean)containsWithId:(id)o {
  if ([o isKindOfClass:[NSString class]]) {
    if (useNormalizedLookup_) {
      return ([((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(phraseTable_)) lookupNormalizedWithNSString:(NSString *) cast_chk(o, [NSString class])] != nil);
    }
    else {
      return ([((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(phraseTable_)) lookupWithNSString:(NSString *) cast_chk(o, [NSString class])] != nil);
    }
  }
  else {
    return false;
  }
}

- (id<JavaUtilIterator>)iterator {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"iterator is not supported for PhraseTable.PhraseStringCollection");
}

- (IOSObjectArray *)toArray {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"toArray is not supported for PhraseTable.PhraseStringCollection");
}

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"toArray is not supported for PhraseTable.PhraseStringCollection");
}

- (jboolean)addWithId:(NSString *)s {
  return [((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(phraseTable_)) addPhraseWithNSString:s];
}

- (jboolean)removeWithId:(id)o {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"Remove is not supported for PhraseTable.PhraseStringCollection");
}

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)c {
  for (id __strong o in nil_chk(c)) {
    if (![self containsWithId:o]) {
      return false;
    }
  }
  return true;
}

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c {
  jboolean modified = false;
  for (NSString * __strong s in nil_chk(c)) {
    if ([self addWithId:s]) {
      modified = true;
    }
  }
  return modified;
}

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c {
  jboolean modified = false;
  for (id __strong o in nil_chk(c)) {
    if ([self removeWithId:o]) {
      modified = true;
    }
  }
  return modified;
}

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"retainAll is not supported for PhraseTable.PhraseStringCollection");
}

- (void)clear {
  [((EduStanfordNlpLingTokensregexPhraseTable *) nil_chk(phraseTable_)) clear];
}

- (id<JavaUtilStreamStream>)parallelStream {
  return JavaUtilCollection_parallelStream(self);
}

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)arg0 {
  return JavaUtilCollection_removeIfWithJavaUtilFunctionPredicate_(self, arg0);
}

- (id<JavaUtilSpliterator>)spliterator {
  return JavaUtilCollection_spliterator(self);
}

- (id<JavaUtilStreamStream>)stream {
  return JavaUtilCollection_stream(self);
}

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)arg0 {
  JavaLangIterable_forEachWithJavaUtilFunctionConsumer_(self, arg0);
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LJavaUtilIterator;", 0x1, -1, -1, -1, 3, -1, -1 },
    { NULL, "[LNSObject;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[LNSObject;", 0x1, 4, 5, -1, 6, -1, -1 },
    { NULL, "Z", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 9, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 10, 11, -1, 12, -1, -1 },
    { NULL, "Z", 0x1, 13, 11, -1, 14, -1, -1 },
    { NULL, "Z", 0x1, 15, 11, -1, 12, -1, -1 },
    { NULL, "Z", 0x1, 16, 11, -1, 12, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpLingTokensregexPhraseTable:withBoolean:);
  methods[1].selector = @selector(size);
  methods[2].selector = @selector(isEmpty);
  methods[3].selector = @selector(containsWithId:);
  methods[4].selector = @selector(iterator);
  methods[5].selector = @selector(toArray);
  methods[6].selector = @selector(toArrayWithNSObjectArray:);
  methods[7].selector = @selector(addWithId:);
  methods[8].selector = @selector(removeWithId:);
  methods[9].selector = @selector(containsAllWithJavaUtilCollection:);
  methods[10].selector = @selector(addAllWithJavaUtilCollection:);
  methods[11].selector = @selector(removeAllWithJavaUtilCollection:);
  methods[12].selector = @selector(retainAllWithJavaUtilCollection:);
  methods[13].selector = @selector(clear);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "phraseTable_", "LEduStanfordNlpLingTokensregexPhraseTable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "useNormalizedLookup_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexPhraseTable;Z", "contains", "LNSObject;", "()Ljava/util/Iterator<Ljava/lang/String;>;", "toArray", "[LNSObject;", "<T:Ljava/lang/Object;>([TT;)[TT;", "add", "LNSString;", "remove", "containsAll", "LJavaUtilCollection;", "(Ljava/util/Collection<*>;)Z", "addAll", "(Ljava/util/Collection<+Ljava/lang/String;>;)Z", "removeAll", "retainAll", "LEduStanfordNlpLingTokensregexPhraseTable;", "Ljava/lang/Object;Ljava/util/Collection<Ljava/lang/String;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection = { "PhraseStringCollection", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x9, 14, 2, 17, -1, -1, 18, -1 };
  return &_EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection;
}

@end

void EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection_initWithEduStanfordNlpLingTokensregexPhraseTable_withBoolean_(EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection *self, EduStanfordNlpLingTokensregexPhraseTable *phraseTable, jboolean useNormalizedLookup) {
  NSObject_init(self);
  self->phraseTable_ = phraseTable;
  self->useNormalizedLookup_ = useNormalizedLookup;
}

EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection *new_EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection_initWithEduStanfordNlpLingTokensregexPhraseTable_withBoolean_(EduStanfordNlpLingTokensregexPhraseTable *phraseTable, jboolean useNormalizedLookup) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection, initWithEduStanfordNlpLingTokensregexPhraseTable_withBoolean_, phraseTable, useNormalizedLookup)
}

EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection *create_EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection_initWithEduStanfordNlpLingTokensregexPhraseTable_withBoolean_(EduStanfordNlpLingTokensregexPhraseTable *phraseTable, jboolean useNormalizedLookup) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection, initWithEduStanfordNlpLingTokensregexPhraseTable_withBoolean_, phraseTable, useNormalizedLookup)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexPhraseTable_PhraseStringCollection)
