//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/ling/tokensregex/MultiPatternMatcher.java
//

#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/ling/tokensregex/BasicSequenceMatchResult.h"
#include "edu/stanford/nlp/ling/tokensregex/MultiPatternMatcher.h"
#include "edu/stanford/nlp/ling/tokensregex/SequenceMatchResult.h"
#include "edu/stanford/nlp/ling/tokensregex/SequenceMatcher.h"
#include "edu/stanford/nlp/ling/tokensregex/SequencePattern.h"
#include "edu/stanford/nlp/util/IntervalTree.h"
#include "edu/stanford/nlp/util/Iterables.h"
#include "edu/stanford/nlp/util/RuntimeInterruptedException.h"
#include "java/lang/Iterable.h"
#include "java/lang/Thread.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/Comparator.h"
#include "java/util/LinkedHashSet.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "java/util/function/Function.h"

#pragma clang diagnostic ignored "-Wprotocol"

@implementation EduStanfordNlpLingTokensregexMultiPatternMatcher

- (instancetype)initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger:(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger>)patternTrigger
                                                                         withJavaUtilCollection:(id<JavaUtilCollection>)patterns {
  EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withJavaUtilCollection_(self, patternTrigger, patterns);
  return self;
}

- (instancetype)initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger:(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger>)patternTrigger
                                          withEduStanfordNlpLingTokensregexSequencePatternArray:(IOSObjectArray *)patterns {
  EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withEduStanfordNlpLingTokensregexSequencePatternArray_(self, patternTrigger, patterns);
  return self;
}

- (instancetype)initWithJavaUtilCollection:(id<JavaUtilCollection>)patterns {
  EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithJavaUtilCollection_(self, patterns);
  return self;
}

- (instancetype)initWithEduStanfordNlpLingTokensregexSequencePatternArray:(IOSObjectArray *)patterns {
  EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexSequencePatternArray_(self, patterns);
  return self;
}

- (id<JavaUtilList>)findNonOverlappingWithJavaUtilList:(id<JavaUtilList>)elements {
  return [self findNonOverlappingWithJavaUtilList:elements withJavaUtilComparator:JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, DEFAULT_COMPARATOR)];
}

- (id<JavaUtilList>)findNonOverlappingWithJavaUtilList:(id<JavaUtilList>)elements
                                withJavaUtilComparator:(id<JavaUtilComparator>)cmp {
  id<JavaUtilCollection> triggered = [self getTriggeredPatternsWithJavaUtilList:elements];
  id<JavaUtilList> all = new_JavaUtilArrayList_init();
  jint i = 0;
  for (EduStanfordNlpLingTokensregexSequencePattern * __strong p in nil_chk(triggered)) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    EduStanfordNlpLingTokensregexSequenceMatcher *m = [((EduStanfordNlpLingTokensregexSequencePattern *) nil_chk(p)) getMatcherWithJavaUtilList:elements];
    [((EduStanfordNlpLingTokensregexSequenceMatcher *) nil_chk(m)) setMatchWithResultWithBoolean:matchWithResult_];
    [m setOrderWithInt:i];
    while ([m find]) {
      [all addWithId:[m toBasicSequenceMatchResult]];
    }
    i++;
  }
  id<JavaUtilList> res = EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(all, JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, TO_INTERVAL), cmp);
  JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(res, JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, OFFSET_COMPARATOR));
  return res;
}

- (id<JavaUtilList>)findWithJavaUtilList:(id<JavaUtilList>)elements
withEduStanfordNlpLingTokensregexSequenceMatcher_FindType:(EduStanfordNlpLingTokensregexSequenceMatcher_FindType *)findType {
  id<JavaUtilCollection> triggered = [self getTriggeredPatternsWithJavaUtilList:elements];
  id<JavaUtilList> all = new_JavaUtilArrayList_init();
  jint i = 0;
  for (EduStanfordNlpLingTokensregexSequencePattern * __strong p in nil_chk(triggered)) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    EduStanfordNlpLingTokensregexSequenceMatcher *m = [((EduStanfordNlpLingTokensregexSequencePattern *) nil_chk(p)) getMatcherWithJavaUtilList:elements];
    [((EduStanfordNlpLingTokensregexSequenceMatcher *) nil_chk(m)) setMatchWithResultWithBoolean:matchWithResult_];
    [m setFindTypeWithEduStanfordNlpLingTokensregexSequenceMatcher_FindType:findType];
    [m setOrderWithInt:i];
    while ([m find]) {
      [all addWithId:[m toBasicSequenceMatchResult]];
    }
    i++;
  }
  id<JavaUtilList> res = EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(all, JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, TO_INTERVAL), JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, DEFAULT_COMPARATOR));
  JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(res, JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, OFFSET_COMPARATOR));
  return res;
}

- (id<JavaUtilList>)findNonOverlappingMaxScoreWithJavaUtilList:(id<JavaUtilList>)elements {
  return [self findNonOverlappingMaxScoreWithJavaUtilList:elements withJavaUtilFunctionFunction:JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, SCORER)];
}

- (id<JavaUtilList>)findNonOverlappingMaxScoreWithJavaUtilList:(id<JavaUtilList>)elements
                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)scorer {
  id<JavaUtilCollection> triggered = [self getTriggeredPatternsWithJavaUtilList:elements];
  id<JavaUtilList> all = new_JavaUtilArrayList_init();
  jint i = 0;
  for (EduStanfordNlpLingTokensregexSequencePattern * __strong p in nil_chk(triggered)) {
    EduStanfordNlpLingTokensregexSequenceMatcher *m = [((EduStanfordNlpLingTokensregexSequencePattern *) nil_chk(p)) getMatcherWithJavaUtilList:elements];
    [((EduStanfordNlpLingTokensregexSequenceMatcher *) nil_chk(m)) setMatchWithResultWithBoolean:matchWithResult_];
    [m setOrderWithInt:i];
    while ([m find]) {
      [all addWithId:[m toBasicSequenceMatchResult]];
    }
    i++;
  }
  id<JavaUtilList> res = EduStanfordNlpUtilIntervalTree_getNonOverlappingMaxScoreWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilFunctionFunction_(all, JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, TO_INTERVAL), scorer);
  JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(res, JreLoadStatic(EduStanfordNlpLingTokensregexSequenceMatchResult, OFFSET_COMPARATOR));
  return res;
}

- (id<JavaLangIterable>)findAllNonOverlappingMatchesPerPatternWithJavaUtilList:(id<JavaUtilList>)elements {
  id<JavaUtilCollection> triggered = [self getTriggeredPatternsWithJavaUtilList:elements];
  id<JavaUtilList> allMatches = new_JavaUtilArrayList_initWithInt_([((id<JavaUtilList>) nil_chk(elements)) size]);
  for (EduStanfordNlpLingTokensregexSequencePattern * __strong p in nil_chk(triggered)) {
    EduStanfordNlpLingTokensregexSequenceMatcher *m = [((EduStanfordNlpLingTokensregexSequencePattern *) nil_chk(p)) getMatcherWithJavaUtilList:elements];
    [((EduStanfordNlpLingTokensregexSequenceMatcher *) nil_chk(m)) setMatchWithResultWithBoolean:matchWithResult_];
    id<JavaLangIterable> matches = [m findAllNonOverlapping];
    [allMatches addWithId:matches];
  }
  return EduStanfordNlpUtilIterables_chainWithJavaLangIterable_(allMatches);
}

- (id<JavaUtilCollection>)getTriggeredPatternsWithJavaUtilList:(id<JavaUtilList>)elements {
  if (patternTrigger_ != nil) {
    return [patternTrigger_ applyWithId:elements];
  }
  else {
    return patterns_;
  }
}

- (jboolean)isMatchWithResult {
  return matchWithResult_;
}

- (void)setMatchWithResultWithBoolean:(jboolean)matchWithResult {
  self->matchWithResult_ = matchWithResult;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, NULL, 0x81, -1, 2, -1, 3, -1, -1 },
    { NULL, NULL, 0x1, -1, 4, -1, 5, -1, -1 },
    { NULL, NULL, 0x81, -1, 6, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 7, 8, -1, 9, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 7, 10, -1, 11, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 12, 13, -1, 14, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 15, 8, -1, 9, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 15, 16, -1, 17, -1, -1 },
    { NULL, "LJavaLangIterable;", 0x1, 18, 8, -1, 19, -1, -1 },
    { NULL, "LJavaUtilCollection;", 0x1, 20, 8, -1, 21, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 22, 23, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger:withJavaUtilCollection:);
  methods[1].selector = @selector(initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger:withEduStanfordNlpLingTokensregexSequencePatternArray:);
  methods[2].selector = @selector(initWithJavaUtilCollection:);
  methods[3].selector = @selector(initWithEduStanfordNlpLingTokensregexSequencePatternArray:);
  methods[4].selector = @selector(findNonOverlappingWithJavaUtilList:);
  methods[5].selector = @selector(findNonOverlappingWithJavaUtilList:withJavaUtilComparator:);
  methods[6].selector = @selector(findWithJavaUtilList:withEduStanfordNlpLingTokensregexSequenceMatcher_FindType:);
  methods[7].selector = @selector(findNonOverlappingMaxScoreWithJavaUtilList:);
  methods[8].selector = @selector(findNonOverlappingMaxScoreWithJavaUtilList:withJavaUtilFunctionFunction:);
  methods[9].selector = @selector(findAllNonOverlappingMatchesPerPatternWithJavaUtilList:);
  methods[10].selector = @selector(getTriggeredPatternsWithJavaUtilList:);
  methods[11].selector = @selector(isMatchWithResult);
  methods[12].selector = @selector(setMatchWithResultWithBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "patterns_", "LJavaUtilCollection;", .constantValue.asLong = 0, 0x0, -1, -1, 24, -1 },
    { "patternTrigger_", "LEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger;", .constantValue.asLong = 0, 0x0, -1, -1, 25, -1 },
    { "matchWithResult_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger;LJavaUtilCollection;", "(Ledu/stanford/nlp/ling/tokensregex/MultiPatternMatcher$SequencePatternTrigger<TT;>;Ljava/util/Collection<+Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;)V", "LEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger;[LEduStanfordNlpLingTokensregexSequencePattern;", "(Ledu/stanford/nlp/ling/tokensregex/MultiPatternMatcher$SequencePatternTrigger<TT;>;[Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;)V", "LJavaUtilCollection;", "(Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;)V", "[LEduStanfordNlpLingTokensregexSequencePattern;", "findNonOverlapping", "LJavaUtilList;", "(Ljava/util/List<+TT;>;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult<TT;>;>;", "LJavaUtilList;LJavaUtilComparator;", "(Ljava/util/List<+TT;>;Ljava/util/Comparator<-Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult;>;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult<TT;>;>;", "find", "LJavaUtilList;LEduStanfordNlpLingTokensregexSequenceMatcher_FindType;", "(Ljava/util/List<+TT;>;Ledu/stanford/nlp/ling/tokensregex/SequenceMatcher$FindType;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult<TT;>;>;", "findNonOverlappingMaxScore", "LJavaUtilList;LJavaUtilFunctionFunction;", "(Ljava/util/List<+TT;>;Ljava/util/function/Function<-Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult;Ljava/lang/Double;>;)Ljava/util/List<Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult<TT;>;>;", "findAllNonOverlappingMatchesPerPattern", "(Ljava/util/List<+TT;>;)Ljava/lang/Iterable<Ledu/stanford/nlp/ling/tokensregex/SequenceMatchResult<TT;>;>;", "getTriggeredPatterns", "(Ljava/util/List<+TT;>;)Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;", "setMatchWithResult", "Z", "Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;", "Ledu/stanford/nlp/ling/tokensregex/MultiPatternMatcher$SequencePatternTrigger<TT;>;", "LEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger;LEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger;LEduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger;", "<T:Ljava/lang/Object;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexMultiPatternMatcher = { "MultiPatternMatcher", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x1, 13, 3, -1, 26, -1, 27, -1 };
  return &_EduStanfordNlpLingTokensregexMultiPatternMatcher;
}

@end

void EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withJavaUtilCollection_(EduStanfordNlpLingTokensregexMultiPatternMatcher *self, id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger> patternTrigger, id<JavaUtilCollection> patterns) {
  NSObject_init(self);
  self->matchWithResult_ = false;
  self->patterns_ = new_JavaUtilArrayList_init();
  [self->patterns_ addAllWithJavaUtilCollection:patterns];
  self->patternTrigger_ = patternTrigger;
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *new_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withJavaUtilCollection_(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger> patternTrigger, id<JavaUtilCollection> patterns) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withJavaUtilCollection_, patternTrigger, patterns)
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *create_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withJavaUtilCollection_(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger> patternTrigger, id<JavaUtilCollection> patterns) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withJavaUtilCollection_, patternTrigger, patterns)
}

void EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withEduStanfordNlpLingTokensregexSequencePatternArray_(EduStanfordNlpLingTokensregexMultiPatternMatcher *self, id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger> patternTrigger, IOSObjectArray *patterns) {
  EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexSequencePatternArray_(self, patterns);
  self->patternTrigger_ = patternTrigger;
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *new_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withEduStanfordNlpLingTokensregexSequencePatternArray_(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger> patternTrigger, IOSObjectArray *patterns) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withEduStanfordNlpLingTokensregexSequencePatternArray_, patternTrigger, patterns)
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *create_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withEduStanfordNlpLingTokensregexSequencePatternArray_(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger> patternTrigger, IOSObjectArray *patterns) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger_withEduStanfordNlpLingTokensregexSequencePatternArray_, patternTrigger, patterns)
}

void EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithJavaUtilCollection_(EduStanfordNlpLingTokensregexMultiPatternMatcher *self, id<JavaUtilCollection> patterns) {
  NSObject_init(self);
  self->matchWithResult_ = false;
  self->patterns_ = patterns;
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *new_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithJavaUtilCollection_(id<JavaUtilCollection> patterns) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithJavaUtilCollection_, patterns)
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *create_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithJavaUtilCollection_(id<JavaUtilCollection> patterns) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithJavaUtilCollection_, patterns)
}

void EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexSequencePatternArray_(EduStanfordNlpLingTokensregexMultiPatternMatcher *self, IOSObjectArray *patterns) {
  NSObject_init(self);
  self->matchWithResult_ = false;
  self->patterns_ = new_JavaUtilArrayList_initWithInt_(((IOSObjectArray *) nil_chk(patterns))->size_);
  {
    IOSObjectArray *a__ = patterns;
    EduStanfordNlpLingTokensregexSequencePattern * const *b__ = a__->buffer_;
    EduStanfordNlpLingTokensregexSequencePattern * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      EduStanfordNlpLingTokensregexSequencePattern *p = *b__++;
      [((id<JavaUtilCollection>) nil_chk(self->patterns_)) addWithId:p];
    }
  }
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *new_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexSequencePatternArray_(IOSObjectArray *patterns) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithEduStanfordNlpLingTokensregexSequencePatternArray_, patterns)
}

EduStanfordNlpLingTokensregexMultiPatternMatcher *create_EduStanfordNlpLingTokensregexMultiPatternMatcher_initWithEduStanfordNlpLingTokensregexSequencePatternArray_(IOSObjectArray *patterns) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher, initWithEduStanfordNlpLingTokensregexSequencePatternArray_, patterns)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexMultiPatternMatcher)

@implementation EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexMultiPatternMatcher;", "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/function/Function<TT;Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger = { "NodePatternTrigger", "edu.stanford.nlp.ling.tokensregex", ptrTable, NULL, NULL, 7, 0x609, 0, 0, 0, -1, -1, 1, -1 };
  return &_EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger)

@implementation EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexMultiPatternMatcher;", "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/function/Function<Ljava/util/List<+TT;>;Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger = { "SequencePatternTrigger", "edu.stanford.nlp.ling.tokensregex", ptrTable, NULL, NULL, 7, 0x609, 0, 0, 0, -1, -1, 1, -1 };
  return &_EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexMultiPatternMatcher_SequencePatternTrigger)

@implementation EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger

- (instancetype)initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger:(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger>)trigger {
  EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger_(self, trigger);
  return self;
}

- (id<JavaUtilCollection>)applyWithId:(id<JavaUtilList>)elements {
  id<JavaUtilSet> triggeredPatterns = new_JavaUtilLinkedHashSet_init();
  for (id __strong node in nil_chk(elements)) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    id<JavaUtilCollection> triggered = [((id<EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger>) nil_chk(trigger_)) applyWithId:node];
    [triggeredPatterns addAllWithJavaUtilCollection:triggered];
  }
  return triggeredPatterns;
}

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "LJavaUtilCollection;", 0x1, 2, 3, -1, 4, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger:);
  methods[1].selector = @selector(applyWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "trigger_", "LEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger;", .constantValue.asLong = 0, 0x0, -1, -1, 5, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger;", "(Ledu/stanford/nlp/ling/tokensregex/MultiPatternMatcher$NodePatternTrigger<TT;>;)V", "apply", "LJavaUtilList;", "(Ljava/util/List<+TT;>;)Ljava/util/Collection<Ledu/stanford/nlp/ling/tokensregex/SequencePattern<TT;>;>;", "Ledu/stanford/nlp/ling/tokensregex/MultiPatternMatcher$NodePatternTrigger<TT;>;", "LEduStanfordNlpLingTokensregexMultiPatternMatcher;", "<T:Ljava/lang/Object;>Ljava/lang/Object;Ledu/stanford/nlp/ling/tokensregex/MultiPatternMatcher$SequencePatternTrigger<TT;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger = { "BasicSequencePatternTrigger", "edu.stanford.nlp.ling.tokensregex", ptrTable, methods, fields, 7, 0x9, 2, 1, 6, -1, -1, 7, -1 };
  return &_EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger;
}

@end

void EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger_(EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger *self, id<EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger> trigger) {
  NSObject_init(self);
  self->trigger_ = trigger;
}

EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger *new_EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger_(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger> trigger) {
  J2OBJC_NEW_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger, initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger_, trigger)
}

EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger *create_EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger_initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger_(id<EduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger> trigger) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger, initWithEduStanfordNlpLingTokensregexMultiPatternMatcher_NodePatternTrigger_, trigger)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpLingTokensregexMultiPatternMatcher_BasicSequencePatternTrigger)
