//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/parser/lexparser/CNFTransformers.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/ling/CategoryWordTag.h"
#include "edu/stanford/nlp/ling/Label.h"
#include "edu/stanford/nlp/ling/LabelFactory.h"
#include "edu/stanford/nlp/parser/lexparser/CNFTransformers.h"
#include "edu/stanford/nlp/parser/lexparser/Options.h"
#include "edu/stanford/nlp/parser/lexparser/TreebankAnnotator.h"
#include "edu/stanford/nlp/trees/Tree.h"
#include "edu/stanford/nlp/trees/TreeFactory.h"
#include "java/io/PrintStream.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collections.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"

@interface EduStanfordNlpParserLexparserCNFTransformers ()

- (instancetype)init;

@end

__attribute__((unused)) static void EduStanfordNlpParserLexparserCNFTransformers_init(EduStanfordNlpParserLexparserCNFTransformers *self);

__attribute__((unused)) static EduStanfordNlpParserLexparserCNFTransformers *new_EduStanfordNlpParserLexparserCNFTransformers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpParserLexparserCNFTransformers *create_EduStanfordNlpParserLexparserCNFTransformers_init();

@implementation EduStanfordNlpParserLexparserCNFTransformers

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpParserLexparserCNFTransformers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (void)mainWithNSStringArray:(IOSObjectArray *)args {
  EduStanfordNlpParserLexparserCNFTransformers_mainWithNSStringArray_(args);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(mainWithNSStringArray:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "main", "[LNSString;", "LEduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer;LEduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer;" };
  static const J2ObjcClassInfo _EduStanfordNlpParserLexparserCNFTransformers = { "CNFTransformers", "edu.stanford.nlp.parser.lexparser", ptrTable, methods, NULL, 7, 0x1, 2, 0, -1, 2, -1, -1, -1 };
  return &_EduStanfordNlpParserLexparserCNFTransformers;
}

@end

void EduStanfordNlpParserLexparserCNFTransformers_init(EduStanfordNlpParserLexparserCNFTransformers *self) {
  NSObject_init(self);
}

EduStanfordNlpParserLexparserCNFTransformers *new_EduStanfordNlpParserLexparserCNFTransformers_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpParserLexparserCNFTransformers, init)
}

EduStanfordNlpParserLexparserCNFTransformers *create_EduStanfordNlpParserLexparserCNFTransformers_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpParserLexparserCNFTransformers, init)
}

void EduStanfordNlpParserLexparserCNFTransformers_mainWithNSStringArray_(IOSObjectArray *args) {
  EduStanfordNlpParserLexparserCNFTransformers_initialize();
  *JreLoadStaticRef(EduStanfordNlpLingCategoryWordTag, printWordTag) = false;
  NSString *path = IOSObjectArray_Get(nil_chk(args), 0);
  id<JavaUtilList> trees = EduStanfordNlpParserLexparserTreebankAnnotator_getTreesWithNSString_withInt_withInt_withInt_withInt_(path, 200, 219, 0, 10);
  id<JavaUtilList> annotatedTrees = [new_EduStanfordNlpParserLexparserTreebankAnnotator_initWithEduStanfordNlpParserLexparserOptions_withNSString_(new_EduStanfordNlpParserLexparserOptions_init(), path) annotateTreesWithJavaUtilList:trees];
  for (EduStanfordNlpTreesTree * __strong tree in nil_chk(annotatedTrees)) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"ORIGINAL:\n"];
    [((EduStanfordNlpTreesTree *) nil_chk(tree)) pennPrint];
    [JreLoadStatic(JavaLangSystem, out) printlnWithNSString:@"CNFed:\n"];
    EduStanfordNlpTreesTree *cnfTree = [new_EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer_init() transformTreeWithEduStanfordNlpTreesTree:tree];
    [((EduStanfordNlpTreesTree *) nil_chk(cnfTree)) pennPrint];
    [JreLoadStatic(JavaLangSystem, out) printlnWithNSString:@"UnCNFed:\n"];
    EduStanfordNlpTreesTree *unCNFTree = [new_EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer_init() transformTreeWithEduStanfordNlpTreesTree:cnfTree];
    [((EduStanfordNlpTreesTree *) nil_chk(unCNFTree)) pennPrint];
    [JreLoadStatic(JavaLangSystem, out) printlnWithNSString:@"\n\n"];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpParserLexparserCNFTransformers)

@implementation EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer

- (EduStanfordNlpTreesTree *)transformTreeWithEduStanfordNlpTreesTree:(EduStanfordNlpTreesTree *)t {
  if ([((EduStanfordNlpTreesTree *) nil_chk(t)) isLeaf]) {
    return [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newLeafWithEduStanfordNlpLingLabel:[t label]];
  }
  IOSObjectArray *children = [t children];
  if (((IOSObjectArray *) nil_chk(children))->size_ > 1 || [t isPreTerminal] || [((NSString *) nil_chk([((id<EduStanfordNlpLingLabel>) nil_chk([t label])) value])) hasPrefix:@"ROOT"]) {
    id<EduStanfordNlpLingLabel> label = [t label];
    IOSObjectArray *transformedChildren = [IOSObjectArray newArrayWithLength:children->size_ type:EduStanfordNlpTreesTree_class_()];
    for (jint childIndex = 0; childIndex < children->size_; childIndex++) {
      EduStanfordNlpTreesTree *child = IOSObjectArray_Get(children, childIndex);
      (void) IOSObjectArray_Set(transformedChildren, childIndex, [self transformTreeWithEduStanfordNlpTreesTree:child]);
    }
    return [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newTreeNodeWithEduStanfordNlpLingLabel:label withJavaUtilList:JavaUtilArrays_asListWithNSObjectArray_(transformedChildren)];
  }
  EduStanfordNlpTreesTree *tree = t;
  id<JavaUtilList> conjoinedList = new_JavaUtilArrayList_init();
  while (((IOSObjectArray *) nil_chk([((EduStanfordNlpTreesTree *) nil_chk(tree)) children]))->size_ == 1 && ![tree isPrePreTerminal]) {
    NSString *nodeString = [((id<EduStanfordNlpLingLabel>) nil_chk([tree label])) value];
    if (![((NSString *) nil_chk(nodeString)) hasPrefix:@"@"]) {
      [conjoinedList addWithId:nodeString];
    }
    tree = IOSObjectArray_Get(nil_chk([tree children]), 0);
  }
  NSString *nodeString = [((id<EduStanfordNlpLingLabel>) nil_chk([tree label])) value];
  if (![((NSString *) nil_chk(nodeString)) hasPrefix:@"@"]) {
    [conjoinedList addWithId:nodeString];
  }
  NSString *conjoinedLabels;
  if ([conjoinedList size] > 1) {
    JavaLangStringBuilder *conjoinedLabelsBuilder = new_JavaLangStringBuilder_init();
    for (NSString * __strong s in conjoinedList) {
      (void) [conjoinedLabelsBuilder appendWithNSString:@"&"];
      (void) [conjoinedLabelsBuilder appendWithNSString:s];
    }
    conjoinedLabels = [conjoinedLabelsBuilder description];
  }
  else if ([conjoinedList size] == 1) {
    conjoinedLabels = [((id<JavaUtilIterator>) nil_chk([conjoinedList iterator])) next];
  }
  else {
    return [self transformTreeWithEduStanfordNlpTreesTree:IOSObjectArray_Get(nil_chk([t children]), 0)];
  }
  children = [tree children];
  id<EduStanfordNlpLingLabel> label = [((id<EduStanfordNlpLingLabelFactory>) nil_chk([((id<EduStanfordNlpLingLabel>) nil_chk([t label])) labelFactory])) newLabelWithNSString:conjoinedLabels];
  IOSObjectArray *transformedChildren = [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(children))->size_ type:EduStanfordNlpTreesTree_class_()];
  for (jint childIndex = 0; childIndex < children->size_; childIndex++) {
    EduStanfordNlpTreesTree *child = IOSObjectArray_Get(children, childIndex);
    (void) IOSObjectArray_Set(transformedChildren, childIndex, [self transformTreeWithEduStanfordNlpTreesTree:child]);
  }
  return [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newTreeNodeWithEduStanfordNlpLingLabel:label withJavaUtilList:JavaUtilArrays_asListWithNSObjectArray_(transformedChildren)];
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LEduStanfordNlpTreesTree;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(transformTreeWithEduStanfordNlpTreesTree:);
  methods[1].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "transformTree", "LEduStanfordNlpTreesTree;", "LEduStanfordNlpParserLexparserCNFTransformers;" };
  static const J2ObjcClassInfo _EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer = { "ToCNFTransformer", "edu.stanford.nlp.parser.lexparser", ptrTable, methods, NULL, 7, 0x8, 2, 0, 2, -1, -1, -1, -1 };
  return &_EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer;
}

@end

void EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer_init(EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer *self) {
  NSObject_init(self);
}

EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer *new_EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer, init)
}

EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer *create_EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpParserLexparserCNFTransformers_ToCNFTransformer)

@implementation EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer

- (EduStanfordNlpTreesTree *)transformTreeWithEduStanfordNlpTreesTree:(EduStanfordNlpTreesTree *)t {
  if ([((EduStanfordNlpTreesTree *) nil_chk(t)) isLeaf]) {
    return [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newLeafWithEduStanfordNlpLingLabel:[t label]];
  }
  IOSObjectArray *children = [t children];
  IOSObjectArray *transformedChildren = [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(children))->size_ type:EduStanfordNlpTreesTree_class_()];
  for (jint childIndex = 0; childIndex < children->size_; childIndex++) {
    EduStanfordNlpTreesTree *child = IOSObjectArray_Get(children, childIndex);
    (void) IOSObjectArray_Set(transformedChildren, childIndex, [self transformTreeWithEduStanfordNlpTreesTree:child]);
  }
  id<EduStanfordNlpLingLabel> label = [t label];
  if (![((NSString *) nil_chk([((id<EduStanfordNlpLingLabel>) nil_chk(label)) value])) hasPrefix:@"&"]) {
    return [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newTreeNodeWithEduStanfordNlpLingLabel:label withJavaUtilList:JavaUtilArrays_asListWithNSObjectArray_(transformedChildren)];
  }
  IOSObjectArray *nodeStrings = [((NSString *) nil_chk([label value])) split:@"&"];
  jint i = ((IOSObjectArray *) nil_chk(nodeStrings))->size_ - 1;
  label = [((id<EduStanfordNlpLingLabelFactory>) nil_chk([((id<EduStanfordNlpLingLabel>) nil_chk([t label])) labelFactory])) newLabelWithNSString:IOSObjectArray_Get(nodeStrings, i)];
  EduStanfordNlpTreesTree *result = [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newTreeNodeWithEduStanfordNlpLingLabel:label withJavaUtilList:JavaUtilArrays_asListWithNSObjectArray_(transformedChildren)];
  while (i > 1) {
    i--;
    label = [((id<EduStanfordNlpLingLabelFactory>) nil_chk([((id<EduStanfordNlpLingLabel>) nil_chk([t label])) labelFactory])) newLabelWithNSString:IOSObjectArray_Get(nodeStrings, i)];
    result = [((id<EduStanfordNlpTreesTreeFactory>) nil_chk([t treeFactory])) newTreeNodeWithEduStanfordNlpLingLabel:label withJavaUtilList:JavaUtilCollections_singletonListWithId_(result)];
  }
  return result;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LEduStanfordNlpTreesTree;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(transformTreeWithEduStanfordNlpTreesTree:);
  methods[1].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "transformTree", "LEduStanfordNlpTreesTree;", "LEduStanfordNlpParserLexparserCNFTransformers;" };
  static const J2ObjcClassInfo _EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer = { "FromCNFTransformer", "edu.stanford.nlp.parser.lexparser", ptrTable, methods, NULL, 7, 0x8, 2, 0, 2, -1, -1, -1, -1 };
  return &_EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer;
}

@end

void EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer_init(EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer *self) {
  NSObject_init(self);
}

EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer *new_EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer, init)
}

EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer *create_EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpParserLexparserCNFTransformers_FromCNFTransformer)
