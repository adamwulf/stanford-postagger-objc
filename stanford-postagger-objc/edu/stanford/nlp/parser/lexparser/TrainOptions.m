//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/parser/lexparser/TrainOptions.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/ling/CategoryWordTag.h"
#include "edu/stanford/nlp/parser/lexparser/TrainOptions.h"
#include "edu/stanford/nlp/trees/Tree.h"
#include "edu/stanford/nlp/trees/TreeTransformer.h"
#include "java/io/PrintStream.h"
#include "java/io/PrintWriter.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/Set.h"

inline jlong EduStanfordNlpParserLexparserTrainOptions_get_serialVersionUID();
#define EduStanfordNlpParserLexparserTrainOptions_serialVersionUID 72571349843538LL
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpParserLexparserTrainOptions, serialVersionUID, jlong)

__attribute__((unused)) static void EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *self, NSString *__name, jint __ordinal);

__attribute__((unused)) static EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *new_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(NSString *__name, jint __ordinal) NS_RETURNS_RETAINED;

NSString *EduStanfordNlpParserLexparserTrainOptions_DEFAULT_UNK_WORD = @"*UNK*";

@implementation EduStanfordNlpParserLexparserTrainOptions

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpParserLexparserTrainOptions_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jboolean)outsideFactor {
  return !markovFactor_;
}

- (jint)compactGrammar {
  if (markovFactor_) {
    return compactGrammar_;
  }
  return 0;
}

- (void)display {
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:[self description]];
}

- (NSString *)description {
  JavaLangStringBuilder *result = new_JavaLangStringBuilder_init();
  (void) [result appendWithNSString:@"Train parameters:\n"];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" smooth=", smoothing_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" PA=", PA_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" GPA=", gPA_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" selSplit=", selectiveSplit_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$D$$", @" (", selectiveSplitCutOff_, ((deleteSplitters_ != nil) ? (JreStrcat("$@", @"; deleting ", deleteSplitters_)) : @""), @")\n")];
  (void) [result appendWithNSString:JreStrcat("$IC", @" mUnary=", markUnary_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" mUnaryTags=", markUnaryTags_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" sPPT=", splitPrePreT_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" tagPA=", tagPA_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$Z$D$", @" tagSelSplit=", tagSelectiveSplit_, @" (", tagSelectiveSplitCutOff_, @")\n")];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" rightRec=", rightRec_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" leftRec=", leftRec_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" collinsPunc=", collinsPunc_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" markov=", markovFactor_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" mOrd=", markovOrder_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$Z$I$", @" hSelSplit=", hSelSplit_, @" (", HSEL_CUT_, @")\n")];
  (void) [result appendWithNSString:JreStrcat("$IC", @" compactGrammar=", [self compactGrammar], 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" postPA=", postPA_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" postGPA=", postGPA_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$Z$D$", @" selPSplit=", selectivePostSplit_, @" (", selectivePostSplitCutOff_, @")\n")];
  (void) [result appendWithNSString:JreStrcat("$Z$D$", @" tagSelPSplit=", tagSelectivePostSplit_, @" (", tagSelectivePostSplitCutOff_, @")\n")];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" postSplitWithBase=", postSplitWithBaseCategory_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" fractionBeforeUnseenCounting=", fractionBeforeUnseenCounting_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" openClassTypesThreshold=", openClassTypesThreshold_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$@C", @" preTransformer=", preTransformer_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$$C", @" taggedFiles=", taggedFiles_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" predictSplits=", predictSplits_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" splitCount=", splitCount_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" splitRecombineRate=", splitRecombineRate_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" simpleBinarizedLabels=", simpleBinarizedLabels_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" noRebinarization=", noRebinarization_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" trainingThreads=", trainingThreads_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" dvKBest=", dvKBest_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" trainingIterations=", trainingIterations_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" batchSize=", batchSize_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" regCost=", regCost_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" qnIterationsPerBatch=", qnIterationsPerBatch_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" qnEstimates=", qnEstimates_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" qnTolerance=", qnTolerance_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" debugOutputFrequency=", debugOutputFrequency_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$JC", @" randomSeed=", randomSeed_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" learningRate=", learningRate_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" deltaMargin=", deltaMargin_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" unknownNumberVector=", unknownNumberVector_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" unknownDashedWordVectors=", unknownDashedWordVectors_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" unknownCapsVector=", unknownCapsVector_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" unknownChineseYearVector=", unknownChineseYearVector_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" unknownChineseNumberVector=", unknownChineseNumberVector_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" unknownChinesePercentVector=", unknownChinesePercentVector_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" dvSimplifiedModel=", dvSimplifiedModel_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$DC", @" scalingForInit=", scalingForInit_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" maxTrainTimeSeconds=", maxTrainTimeSeconds_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$$C", @" unkWord=", unkWord_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" lowercaseWordVectors=", lowercaseWordVectors_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$@C", @" transformMatrixType=", transformMatrixType_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" useContextWords=", useContextWords_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" trainWordVectors=", trainWordVectors_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$IC", @" stalledIterationLimit=", stalledIterationLimit_, 0x000a)];
  (void) [result appendWithNSString:JreStrcat("$ZC", @" markStrahler=", markStrahler_, 0x000a)];
  return [result description];
}

+ (void)printTrainTreeWithJavaIoPrintWriter:(JavaIoPrintWriter *)pw
                               withNSString:(NSString *)message
                withEduStanfordNlpTreesTree:(EduStanfordNlpTreesTree *)t {
  EduStanfordNlpParserLexparserTrainOptions_printTrainTreeWithJavaIoPrintWriter_withNSString_withEduStanfordNlpTreesTree_(pw, message, t);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(outsideFactor);
  methods[2].selector = @selector(compactGrammar);
  methods[3].selector = @selector(display);
  methods[4].selector = @selector(description);
  methods[5].selector = @selector(printTrainTreeWithJavaIoPrintWriter:withNSString:withEduStanfordNlpTreesTree:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "trainTreeFile_", "LNSString;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "trainLengthLimit_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "cheatPCFG_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "markovFactor_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "markovOrder_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "hSelSplit_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "HSEL_CUT_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "markFinalStates_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "openClassTypesThreshold_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "fractionBeforeUnseenCounting_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "PA_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "gPA_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "postPA_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "postGPA_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "selectiveSplit_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "selectiveSplitCutOff_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "selectivePostSplit_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "selectivePostSplitCutOff_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "postSplitWithBaseCategory_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "sisterAnnotate_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "sisterSplitters_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x1, -1, -1, 3, -1 },
    { "markUnary_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "markUnaryTags_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "splitPrePreT_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "tagPA_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "tagSelectiveSplit_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "tagSelectiveSplitCutOff_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "tagSelectivePostSplit_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "tagSelectivePostSplitCutOff_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "rightRec_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "leftRec_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "collinsPunc_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "splitters_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x1, -1, -1, 3, -1 },
    { "postSplitters_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "deleteSplitters_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x1, -1, -1, 3, -1 },
    { "printTreeTransformations_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "printAnnotatedPW_", "LJavaIoPrintWriter;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "printBinarizedPW_", "LJavaIoPrintWriter;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "printStates_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "compactGrammar_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "leftToRight_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "noTagSplit_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "ruleSmoothing_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "ruleSmoothingAlpha_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "smoothing_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "ruleDiscount_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "printAnnotatedRuleCounts_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "printAnnotatedStateCounts_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "basicCategoryTagsInDependencyGrammar_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "preTransformer_", "LEduStanfordNlpTreesTreeTransformer;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "taggedFiles_", "LNSString;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "predictSplits_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "splitCount_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "splitRecombineRate_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "simpleBinarizedLabels_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "noRebinarization_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "trainingThreads_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_K_BEST", "I", .constantValue.asInt = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_K_BEST, 0x19, -1, -1, -1, -1 },
    { "dvKBest_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_TRAINING_ITERATIONS", "I", .constantValue.asInt = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_TRAINING_ITERATIONS, 0x19, -1, -1, -1, -1 },
    { "trainingIterations_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_BATCH_SIZE", "I", .constantValue.asInt = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_BATCH_SIZE, 0x19, -1, -1, -1, -1 },
    { "batchSize_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_REGCOST", "D", .constantValue.asDouble = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_REGCOST, 0x19, -1, -1, -1, -1 },
    { "regCost_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_QN_ITERATIONS_PER_BATCH", "I", .constantValue.asInt = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_QN_ITERATIONS_PER_BATCH, 0x19, -1, -1, -1, -1 },
    { "qnIterationsPerBatch_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "qnEstimates_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "qnTolerance_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "debugOutputFrequency_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "randomSeed_", "J", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_LEARNING_RATE", "D", .constantValue.asDouble = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_LEARNING_RATE, 0x19, -1, -1, -1, -1 },
    { "learningRate_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_DELTA_MARGIN", "D", .constantValue.asDouble = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_DELTA_MARGIN, 0x19, -1, -1, -1, -1 },
    { "deltaMargin_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "unknownNumberVector_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "unknownDashedWordVectors_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "unknownCapsVector_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "dvSimplifiedModel_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "unknownChineseYearVector_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "unknownChineseNumberVector_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "unknownChinesePercentVector_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_SCALING_FOR_INIT", "D", .constantValue.asDouble = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_SCALING_FOR_INIT, 0x19, -1, -1, -1, -1 },
    { "scalingForInit_", "D", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "maxTrainTimeSeconds_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_UNK_WORD", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 4, -1, -1 },
    { "unkWord_", "LNSString;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "lowercaseWordVectors_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "transformMatrixType_", "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "useContextWords_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "trainWordVectors_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "DEFAULT_STALLED_ITERATION_LIMIT", "I", .constantValue.asInt = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_STALLED_ITERATION_LIMIT, 0x19, -1, -1, -1, -1 },
    { "stalledIterationLimit_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "markStrahler_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "serialVersionUID", "J", .constantValue.asLong = EduStanfordNlpParserLexparserTrainOptions_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toString", "printTrainTree", "LJavaIoPrintWriter;LNSString;LEduStanfordNlpTreesTree;", "Ljava/util/Set<Ljava/lang/String;>;", &EduStanfordNlpParserLexparserTrainOptions_DEFAULT_UNK_WORD, "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;" };
  static const J2ObjcClassInfo _EduStanfordNlpParserLexparserTrainOptions = { "TrainOptions", "edu.stanford.nlp.parser.lexparser", ptrTable, methods, fields, 7, 0x1, 6, 95, -1, 5, -1, -1, -1 };
  return &_EduStanfordNlpParserLexparserTrainOptions;
}

@end

void EduStanfordNlpParserLexparserTrainOptions_init(EduStanfordNlpParserLexparserTrainOptions *self) {
  NSObject_init(self);
  self->trainTreeFile_ = nil;
  self->trainLengthLimit_ = 100000;
  self->cheatPCFG_ = false;
  self->markovFactor_ = false;
  self->markovOrder_ = 1;
  self->hSelSplit_ = false;
  self->HSEL_CUT_ = 10;
  self->markFinalStates_ = true;
  self->openClassTypesThreshold_ = 50;
  self->fractionBeforeUnseenCounting_ = 0.5;
  self->PA_ = true;
  self->gPA_ = false;
  self->postPA_ = false;
  self->postGPA_ = false;
  self->selectiveSplit_ = false;
  self->selectiveSplitCutOff_ = 0.0;
  self->selectivePostSplit_ = false;
  self->selectivePostSplitCutOff_ = 0.0;
  self->postSplitWithBaseCategory_ = false;
  self->sisterAnnotate_ = false;
  self->markUnary_ = 0;
  self->markUnaryTags_ = false;
  self->splitPrePreT_ = false;
  self->tagPA_ = false;
  self->tagSelectiveSplit_ = false;
  self->tagSelectiveSplitCutOff_ = 0.0;
  self->tagSelectivePostSplit_ = false;
  self->tagSelectivePostSplitCutOff_ = 0.0;
  self->rightRec_ = false;
  self->leftRec_ = false;
  self->collinsPunc_ = false;
  self->printTreeTransformations_ = 0;
  self->printStates_ = false;
  self->compactGrammar_ = 3;
  self->leftToRight_ = false;
  self->noTagSplit_ = false;
  self->ruleSmoothing_ = false;
  self->ruleSmoothingAlpha_ = 0.0;
  self->smoothing_ = false;
  self->ruleDiscount_ = 0.0;
  self->printAnnotatedRuleCounts_ = false;
  self->printAnnotatedStateCounts_ = false;
  self->basicCategoryTagsInDependencyGrammar_ = false;
  self->preTransformer_ = nil;
  self->taggedFiles_ = nil;
  self->predictSplits_ = false;
  self->splitCount_ = 1;
  self->splitRecombineRate_ = 0.0;
  self->simpleBinarizedLabels_ = false;
  self->noRebinarization_ = false;
  self->trainingThreads_ = 1;
  self->dvKBest_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_K_BEST;
  self->trainingIterations_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_TRAINING_ITERATIONS;
  self->batchSize_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_BATCH_SIZE;
  self->regCost_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_REGCOST;
  self->qnIterationsPerBatch_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_QN_ITERATIONS_PER_BATCH;
  self->qnEstimates_ = 15;
  self->qnTolerance_ = 15;
  self->debugOutputFrequency_ = 0;
  self->randomSeed_ = 0;
  self->learningRate_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_LEARNING_RATE;
  self->deltaMargin_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_DELTA_MARGIN;
  self->unknownNumberVector_ = true;
  self->unknownDashedWordVectors_ = true;
  self->unknownCapsVector_ = true;
  self->dvSimplifiedModel_ = false;
  self->unknownChineseYearVector_ = true;
  self->unknownChineseNumberVector_ = true;
  self->unknownChinesePercentVector_ = true;
  self->scalingForInit_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_SCALING_FOR_INIT;
  self->maxTrainTimeSeconds_ = 0;
  self->unkWord_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_UNK_WORD;
  self->lowercaseWordVectors_ = false;
  self->transformMatrixType_ = JreLoadEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, DIAGONAL);
  self->useContextWords_ = false;
  self->trainWordVectors_ = true;
  self->stalledIterationLimit_ = EduStanfordNlpParserLexparserTrainOptions_DEFAULT_STALLED_ITERATION_LIMIT;
}

EduStanfordNlpParserLexparserTrainOptions *new_EduStanfordNlpParserLexparserTrainOptions_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpParserLexparserTrainOptions, init)
}

EduStanfordNlpParserLexparserTrainOptions *create_EduStanfordNlpParserLexparserTrainOptions_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpParserLexparserTrainOptions, init)
}

void EduStanfordNlpParserLexparserTrainOptions_printTrainTreeWithJavaIoPrintWriter_withNSString_withEduStanfordNlpTreesTree_(JavaIoPrintWriter *pw, NSString *message, EduStanfordNlpTreesTree *t) {
  EduStanfordNlpParserLexparserTrainOptions_initialize();
  JavaIoPrintWriter *myPW;
  if (pw == nil) {
    myPW = new_JavaIoPrintWriter_initWithJavaIoOutputStream_withBoolean_(JreLoadStatic(JavaLangSystem, out), true);
  }
  else {
    myPW = pw;
  }
  if (message != nil && pw == nil) {
    [myPW printlnWithNSString:message];
  }
  jboolean previousState = JreLoadStatic(EduStanfordNlpLingCategoryWordTag, printWordTag);
  *JreLoadStaticRef(EduStanfordNlpLingCategoryWordTag, printWordTag) = false;
  [((EduStanfordNlpTreesTree *) nil_chk(t)) pennPrintWithJavaIoPrintWriter:myPW];
  *JreLoadStaticRef(EduStanfordNlpLingCategoryWordTag, printWordTag) = previousState;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpParserLexparserTrainOptions)

J2OBJC_INITIALIZED_DEFN(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType)

EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_values_[4];

@implementation EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType

+ (IOSObjectArray *)values {
  return EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_values();
}

+ (EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *)valueOfWithNSString:(NSString *)name {
  return EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_valueOfWithNSString_(name);
}

- (id)copyWithZone:(NSZone *)zone {
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DIAGONAL", "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "RANDOM", "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "OFF_DIAGONAL", "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
    { "RANDOM_ZEROS", "LEduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;", .constantValue.asLong = 0, 0x4019, -1, 5, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, DIAGONAL), &JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, RANDOM), &JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, OFF_DIAGONAL), &JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, RANDOM_ZEROS), "LEduStanfordNlpParserLexparserTrainOptions;", "Ljava/lang/Enum<Ledu/stanford/nlp/parser/lexparser/TrainOptions$TransformMatrixType;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType = { "TransformMatrixType", "edu.stanford.nlp.parser.lexparser", ptrTable, methods, fields, 7, 0x4019, 2, 4, 6, -1, -1, 7, -1 };
  return &_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType;
}

+ (void)initialize {
  if (self == [EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType class]) {
    JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, DIAGONAL) = new_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(@"DIAGONAL", 0);
    JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, RANDOM) = new_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(@"RANDOM", 1);
    JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, OFF_DIAGONAL) = new_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(@"OFF_DIAGONAL", 2);
    JreEnum(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, RANDOM_ZEROS) = new_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(@"RANDOM_ZEROS", 3);
    J2OBJC_SET_INITIALIZED(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType)
  }
}

@end

void EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *new_EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initWithNSString_withInt_(NSString *__name, jint __ordinal) {
  J2OBJC_NEW_IMPL(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType, initWithNSString_withInt_, __name, __ordinal)
}

IOSObjectArray *EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_values() {
  EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initialize();
  return [IOSObjectArray arrayWithObjects:EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_values_ count:4 type:EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_class_()];
}

EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_valueOfWithNSString_(NSString *name) {
  EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initialize();
  for (int i = 0; i < 4; i++) {
    EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *e = EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType *EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_fromOrdinal(NSUInteger ordinal) {
  EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_initialize();
  if (ordinal >= 4) {
    return nil;
  }
  return EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpParserLexparserTrainOptions_TransformMatrixType)
