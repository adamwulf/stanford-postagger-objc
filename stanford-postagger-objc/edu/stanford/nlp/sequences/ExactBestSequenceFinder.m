//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/sequences/ExactBestSequenceFinder.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/sequences/ExactBestSequenceFinder.h"
#include "edu/stanford/nlp/sequences/SequenceModel.h"
#include "edu/stanford/nlp/util/Pair.h"
#include "edu/stanford/nlp/util/RuntimeInterruptedException.h"
#include "java/lang/Double.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Thread.h"
#include "java/util/Arrays.h"

@interface EduStanfordNlpSequencesExactBestSequenceFinder ()

+ (EduStanfordNlpUtilPair *)bestSequenceWithEduStanfordNlpSequencesSequenceModel:(id<EduStanfordNlpSequencesSequenceModel>)ts
                                                                withDoubleArray2:(IOSObjectArray *)linearConstraints;

@end

inline jboolean EduStanfordNlpSequencesExactBestSequenceFinder_get_DEBUG();
#define EduStanfordNlpSequencesExactBestSequenceFinder_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpSequencesExactBestSequenceFinder, DEBUG, jboolean)

__attribute__((unused)) static EduStanfordNlpUtilPair *EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(id<EduStanfordNlpSequencesSequenceModel> ts, IOSObjectArray *linearConstraints);

@implementation EduStanfordNlpSequencesExactBestSequenceFinder

+ (EduStanfordNlpUtilPair *)bestSequenceWithLinearConstraintsWithEduStanfordNlpSequencesSequenceModel:(id<EduStanfordNlpSequencesSequenceModel>)ts
                                                                                     withDoubleArray2:(IOSObjectArray *)linearConstraints {
  return EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithLinearConstraintsWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(ts, linearConstraints);
}

- (IOSIntArray *)bestSequenceWithEduStanfordNlpSequencesSequenceModel:(id<EduStanfordNlpSequencesSequenceModel>)ts {
  return [((EduStanfordNlpUtilPair *) nil_chk(EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(ts, nil))) first];
}

+ (EduStanfordNlpUtilPair *)bestSequenceWithEduStanfordNlpSequencesSequenceModel:(id<EduStanfordNlpSequencesSequenceModel>)ts
                                                                withDoubleArray2:(IOSObjectArray *)linearConstraints {
  return EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(ts, linearConstraints);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpSequencesExactBestSequenceFinder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LEduStanfordNlpUtilPair;", 0x9, 0, 1, -1, 2, -1, -1 },
    { NULL, "[I", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpUtilPair;", 0xa, 3, 1, -1, 2, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(bestSequenceWithLinearConstraintsWithEduStanfordNlpSequencesSequenceModel:withDoubleArray2:);
  methods[1].selector = @selector(bestSequenceWithEduStanfordNlpSequencesSequenceModel:);
  methods[2].selector = @selector(bestSequenceWithEduStanfordNlpSequencesSequenceModel:withDoubleArray2:);
  methods[3].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEBUG", "Z", .constantValue.asBOOL = EduStanfordNlpSequencesExactBestSequenceFinder_DEBUG, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "bestSequenceWithLinearConstraints", "LEduStanfordNlpSequencesSequenceModel;[[D", "(Ledu/stanford/nlp/sequences/SequenceModel;[[D)Ledu/stanford/nlp/util/Pair<[LI;Ljava/lang/Double;>;", "bestSequence", "LEduStanfordNlpSequencesSequenceModel;" };
  static const J2ObjcClassInfo _EduStanfordNlpSequencesExactBestSequenceFinder = { "ExactBestSequenceFinder", "edu.stanford.nlp.sequences", ptrTable, methods, fields, 7, 0x1, 4, 1, -1, -1, -1, -1, -1 };
  return &_EduStanfordNlpSequencesExactBestSequenceFinder;
}

@end

EduStanfordNlpUtilPair *EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithLinearConstraintsWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(id<EduStanfordNlpSequencesSequenceModel> ts, IOSObjectArray *linearConstraints) {
  EduStanfordNlpSequencesExactBestSequenceFinder_initialize();
  return EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(ts, linearConstraints);
}

EduStanfordNlpUtilPair *EduStanfordNlpSequencesExactBestSequenceFinder_bestSequenceWithEduStanfordNlpSequencesSequenceModel_withDoubleArray2_(id<EduStanfordNlpSequencesSequenceModel> ts, IOSObjectArray *linearConstraints) {
  EduStanfordNlpSequencesExactBestSequenceFinder_initialize();
  jint length = [((id<EduStanfordNlpSequencesSequenceModel>) nil_chk(ts)) length];
  jint leftWindow = [ts leftWindow];
  jint rightWindow = [ts rightWindow];
  jint padLength = length + leftWindow + rightWindow;
  if (linearConstraints != nil && linearConstraints->size_ != padLength) @throw new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$I$I$I$I$I", @"linearConstraints.length (", linearConstraints->size_, @") does not match padLength (", padLength, @") of SequenceModel, length==", length, @", leftW=", leftWindow, @", rightW=", rightWindow));
  IOSObjectArray *tags = [IOSObjectArray newArrayWithLength:padLength type:IOSClass_intArray(1)];
  IOSIntArray *tagNum = [IOSIntArray newArrayWithLength:padLength];
  for (jint pos = 0; pos < padLength; pos++) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    (void) IOSObjectArray_Set(tags, pos, [ts getPossibleValuesWithInt:pos]);
    *IOSIntArray_GetRef(tagNum, pos) = ((IOSIntArray *) nil_chk(IOSObjectArray_Get(tags, pos)))->size_;
  }
  IOSIntArray *tempTags = [IOSIntArray newArrayWithLength:padLength];
  IOSIntArray *productSizes = [IOSIntArray newArrayWithLength:padLength];
  jint curProduct = 1;
  for (jint i = 0; i < leftWindow + rightWindow; i++) {
    curProduct *= IOSIntArray_Get(tagNum, i);
  }
  for (jint pos = leftWindow + rightWindow; pos < padLength; pos++) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    if (pos > leftWindow + rightWindow) {
      curProduct /= IOSIntArray_Get(tagNum, pos - leftWindow - rightWindow - 1);
    }
    curProduct *= IOSIntArray_Get(tagNum, pos);
    *IOSIntArray_GetRef(productSizes, pos - rightWindow) = curProduct;
  }
  IOSObjectArray *windowScore = [IOSObjectArray newArrayWithLength:padLength type:IOSClass_doubleArray(1)];
  for (jint pos = leftWindow; pos < leftWindow + length; pos++) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    (void) IOSObjectArray_SetAndConsume(windowScore, pos, [IOSDoubleArray newArrayWithLength:IOSIntArray_Get(productSizes, pos)]);
    JavaUtilArrays_fillWithIntArray_withInt_(tempTags, IOSIntArray_Get(nil_chk(IOSObjectArray_Get(tags, 0)), 0));
    for (jint product = 0; product < IOSIntArray_Get(productSizes, pos); product++) {
      if (JavaLangThread_interrupted()) {
        @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
      }
      jint p = product;
      jint shift = 1;
      for (jint curPos = pos + rightWindow; curPos >= pos - leftWindow; curPos--) {
        *IOSIntArray_GetRef(tempTags, curPos) = IOSIntArray_Get(nil_chk(IOSObjectArray_Get(tags, curPos)), p % IOSIntArray_Get(tagNum, curPos));
        p /= IOSIntArray_Get(tagNum, curPos);
        if (curPos > pos) {
          shift *= IOSIntArray_Get(tagNum, curPos);
        }
      }
      if (IOSIntArray_Get(tempTags, pos) == IOSIntArray_Get(nil_chk(IOSObjectArray_Get(tags, pos)), 0)) {
        IOSDoubleArray *scores = [ts scoresOfWithIntArray:tempTags withInt:pos];
        for (jint t = 0; t < IOSIntArray_Get(tagNum, pos); t++) {
          *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(windowScore, pos)), product + t * shift) = IOSDoubleArray_Get(nil_chk(scores), t);
        }
      }
    }
  }
  IOSObjectArray *score = [IOSObjectArray newArrayWithLength:padLength type:IOSClass_doubleArray(1)];
  IOSObjectArray *trace = [IOSObjectArray newArrayWithLength:padLength type:IOSClass_intArray(1)];
  for (jint pos = 0; pos < padLength; pos++) {
    if (JavaLangThread_interrupted()) {
      @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
    }
    (void) IOSObjectArray_SetAndConsume(score, pos, [IOSDoubleArray newArrayWithLength:IOSIntArray_Get(productSizes, pos)]);
    (void) IOSObjectArray_SetAndConsume(trace, pos, [IOSIntArray newArrayWithLength:IOSIntArray_Get(productSizes, pos)]);
  }
  for (jint pos = leftWindow; pos < length + leftWindow; pos++) {
    for (jint product = 0; product < IOSIntArray_Get(productSizes, pos); product++) {
      if (JavaLangThread_interrupted()) {
        @throw new_EduStanfordNlpUtilRuntimeInterruptedException_init();
      }
      if (pos == leftWindow) {
        *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(score, pos)), product) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(windowScore, pos)), product);
        if (linearConstraints != nil) {
          JrePlusAssignDoubleD(IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(score, pos)), product), IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(linearConstraints, pos)), product % IOSIntArray_Get(tagNum, pos)));
        }
        *IOSIntArray_GetRef(nil_chk(IOSObjectArray_Get(trace, pos)), product) = -1;
      }
      else {
        *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(score, pos)), product) = JavaLangDouble_NEGATIVE_INFINITY;
        *IOSIntArray_GetRef(nil_chk(IOSObjectArray_Get(trace, pos)), product) = -1;
        jint sharedProduct = product / IOSIntArray_Get(tagNum, pos + rightWindow);
        jint factor = IOSIntArray_Get(productSizes, pos) / IOSIntArray_Get(tagNum, pos + rightWindow);
        for (jint newTagNum = 0; newTagNum < IOSIntArray_Get(tagNum, pos - leftWindow - 1); newTagNum++) {
          jint predProduct = newTagNum * factor + sharedProduct;
          jdouble predScore = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(score, pos - 1)), predProduct) + IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(windowScore, pos)), product);
          if (linearConstraints != nil) {
            JrePlusAssignDoubleD(&predScore, IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(linearConstraints, pos)), product % IOSIntArray_Get(tagNum, pos)));
          }
          if (predScore > IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(score, pos)), product)) {
            *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(score, pos)), product) = predScore;
            *IOSIntArray_GetRef(nil_chk(IOSObjectArray_Get(trace, pos)), product) = predProduct;
          }
        }
      }
    }
  }
  jdouble bestFinalScore = JavaLangDouble_NEGATIVE_INFINITY;
  jint bestCurrentProduct = -1;
  for (jint product = 0; product < IOSIntArray_Get(productSizes, leftWindow + length - 1); product++) {
    if (IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(score, leftWindow + length - 1)), product) > bestFinalScore) {
      bestCurrentProduct = product;
      bestFinalScore = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(score, leftWindow + length - 1)), product);
    }
  }
  jint lastProduct = bestCurrentProduct;
  for (jint last = padLength - 1; last >= length - 1 && last >= 0; last--) {
    *IOSIntArray_GetRef(tempTags, last) = IOSIntArray_Get(nil_chk(IOSObjectArray_Get(tags, last)), lastProduct % IOSIntArray_Get(tagNum, last));
    lastProduct /= IOSIntArray_Get(tagNum, last);
  }
  for (jint pos = leftWindow + length - 2; pos >= leftWindow; pos--) {
    jint bestNextProduct = bestCurrentProduct;
    bestCurrentProduct = IOSIntArray_Get(nil_chk(IOSObjectArray_Get(trace, pos + 1)), bestNextProduct);
    *IOSIntArray_GetRef(tempTags, pos - leftWindow) = IOSIntArray_Get(nil_chk(IOSObjectArray_Get(tags, pos - leftWindow)), bestCurrentProduct / (IOSIntArray_Get(productSizes, pos) / IOSIntArray_Get(tagNum, pos - leftWindow)));
  }
  return new_EduStanfordNlpUtilPair_initWithId_withId_(tempTags, JavaLangDouble_valueOfWithDouble_(bestFinalScore));
}

void EduStanfordNlpSequencesExactBestSequenceFinder_init(EduStanfordNlpSequencesExactBestSequenceFinder *self) {
  NSObject_init(self);
}

EduStanfordNlpSequencesExactBestSequenceFinder *new_EduStanfordNlpSequencesExactBestSequenceFinder_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpSequencesExactBestSequenceFinder, init)
}

EduStanfordNlpSequencesExactBestSequenceFinder *create_EduStanfordNlpSequencesExactBestSequenceFinder_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpSequencesExactBestSequenceFinder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpSequencesExactBestSequenceFinder)
