//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/util/IntervalTree.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/util/AbstractIterator.h"
#include "edu/stanford/nlp/util/HasInterval.h"
#include "edu/stanford/nlp/util/Interval.h"
#include "edu/stanford/nlp/util/IntervalTree.h"
#include "java/lang/Boolean.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/Comparable.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/AbstractCollection.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/Comparator.h"
#include "java/util/Iterator.h"
#include "java/util/LinkedList.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/NoSuchElementException.h"
#include "java/util/Queue.h"
#include "java/util/Set.h"
#include "java/util/Stack.h"
#include "java/util/TreeMap.h"
#include "java/util/function/Function.h"

@interface EduStanfordNlpUtilIntervalTree () {
 @public
  EduStanfordNlpUtilIntervalTree_TreeNode *root_;
}

- (void)adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node;

- (void)adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                     withEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)stopAt;

- (void)adjustWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node;

+ (jboolean)containsWithEduStanfordNlpUtilIntervalTree:(EduStanfordNlpUtilIntervalTree *)tree
                        withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                          withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)containsTargetFunction;

+ (jboolean)containsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                                 withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                                   withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)containsTargetFunction;

@end

J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree, root_, EduStanfordNlpUtilIntervalTree_TreeNode *)

inline jdouble EduStanfordNlpUtilIntervalTree_get_defaultAlpha();
#define EduStanfordNlpUtilIntervalTree_defaultAlpha 0.65
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpUtilIntervalTree, defaultAlpha, jdouble)

inline jboolean EduStanfordNlpUtilIntervalTree_get_debug();
#define EduStanfordNlpUtilIntervalTree_debug false
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpUtilIntervalTree, debug, jboolean)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree *self, EduStanfordNlpUtilIntervalTree_TreeNode *node, EduStanfordNlpUtilIntervalTree_TreeNode *stopAt);

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_adjustWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree *self, EduStanfordNlpUtilIntervalTree_TreeNode *node);

__attribute__((unused)) static jboolean EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(EduStanfordNlpUtilIntervalTree *tree, EduStanfordNlpUtilInterval *target, id<JavaUtilFunctionFunction> containsTargetFunction);

__attribute__((unused)) static jboolean EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(EduStanfordNlpUtilIntervalTree_TreeNode *node, EduStanfordNlpUtilInterval *target, id<JavaUtilFunctionFunction> containsTargetFunction);

@interface EduStanfordNlpUtilIntervalTree_TreeNodeIterator : EduStanfordNlpUtilAbstractIterator {
 @public
  EduStanfordNlpUtilIntervalTree_TreeNode *node_;
  id<JavaUtilIterator> curIter_;
  jint stage_;
  id<EduStanfordNlpUtilHasInterval> next_;
}

- (instancetype)initWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node;

- (jboolean)hasNext;

- (id<EduStanfordNlpUtilHasInterval>)next;

- (id<EduStanfordNlpUtilHasInterval>)getNext;

@end

J2OBJC_EMPTY_STATIC_INIT(EduStanfordNlpUtilIntervalTree_TreeNodeIterator)

J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_TreeNodeIterator, node_, EduStanfordNlpUtilIntervalTree_TreeNode *)
J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_TreeNodeIterator, curIter_, id<JavaUtilIterator>)
J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_TreeNodeIterator, next_, id<EduStanfordNlpUtilHasInterval>)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree_TreeNodeIterator *self, EduStanfordNlpUtilIntervalTree_TreeNode *node);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_TreeNodeIterator *new_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree_TreeNode *node) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_TreeNodeIterator *create_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree_TreeNode *node);

__attribute__((unused)) static id<EduStanfordNlpUtilHasInterval> EduStanfordNlpUtilIntervalTree_TreeNodeIterator_getNext(EduStanfordNlpUtilIntervalTree_TreeNodeIterator *self);

J2OBJC_TYPE_LITERAL_HEADER(EduStanfordNlpUtilIntervalTree_TreeNodeIterator)

@interface EduStanfordNlpUtilIntervalTree_ContainsValueFunction : NSObject < JavaUtilFunctionFunction > {
 @public
  id<EduStanfordNlpUtilHasInterval> target_;
}

- (instancetype)initWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target;

- (JavaLangBoolean *)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg;

@end

J2OBJC_EMPTY_STATIC_INIT(EduStanfordNlpUtilIntervalTree_ContainsValueFunction)

J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_ContainsValueFunction, target_, id<EduStanfordNlpUtilHasInterval>)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(EduStanfordNlpUtilIntervalTree_ContainsValueFunction *self, id<EduStanfordNlpUtilHasInterval> target);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_ContainsValueFunction *new_EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(id<EduStanfordNlpUtilHasInterval> target) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_ContainsValueFunction *create_EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(id<EduStanfordNlpUtilHasInterval> target);

J2OBJC_TYPE_LITERAL_HEADER(EduStanfordNlpUtilIntervalTree_ContainsValueFunction)

@interface EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction : NSObject < JavaUtilFunctionFunction > {
 @public
  EduStanfordNlpUtilInterval *target_;
  jboolean exact_;
}

- (instancetype)initWithEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                                       withBoolean:(jboolean)exact;

- (JavaLangBoolean *)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg;

@end

J2OBJC_EMPTY_STATIC_INIT(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction)

J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction, target_, EduStanfordNlpUtilInterval *)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction *self, EduStanfordNlpUtilInterval *target, jboolean exact);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction *new_EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilInterval *target, jboolean exact) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction *create_EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilInterval *target, jboolean exact);

J2OBJC_TYPE_LITERAL_HEADER(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction)

@interface EduStanfordNlpUtilIntervalTree_PartialScoredList : NSObject {
 @public
  id object_;
  id lastMatchKey_;
  jint size_;
  jdouble score_;
}

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(EduStanfordNlpUtilIntervalTree_PartialScoredList)

J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_PartialScoredList, object_, id)
J2OBJC_FIELD_SETTER(EduStanfordNlpUtilIntervalTree_PartialScoredList, lastMatchKey_, id)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_PartialScoredList_init(EduStanfordNlpUtilIntervalTree_PartialScoredList *self);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_PartialScoredList *new_EduStanfordNlpUtilIntervalTree_PartialScoredList_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_PartialScoredList *create_EduStanfordNlpUtilIntervalTree_PartialScoredList_init();

J2OBJC_TYPE_LITERAL_HEADER(EduStanfordNlpUtilIntervalTree_PartialScoredList)

@interface EduStanfordNlpUtilIntervalTree_$Lambda$1 : NSObject < JavaUtilFunctionFunction >

- (id)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg;

@end

J2OBJC_STATIC_INIT(EduStanfordNlpUtilIntervalTree_$Lambda$1)

inline EduStanfordNlpUtilIntervalTree_$Lambda$1 *EduStanfordNlpUtilIntervalTree_$Lambda$1_get_instance();
static EduStanfordNlpUtilIntervalTree_$Lambda$1 *EduStanfordNlpUtilIntervalTree_$Lambda$1_instance;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpUtilIntervalTree_$Lambda$1, instance, EduStanfordNlpUtilIntervalTree_$Lambda$1 *)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_$Lambda$1_init(EduStanfordNlpUtilIntervalTree_$Lambda$1 *self);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_$Lambda$1 *new_EduStanfordNlpUtilIntervalTree_$Lambda$1_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_$Lambda$1 *create_EduStanfordNlpUtilIntervalTree_$Lambda$1_init();

@interface EduStanfordNlpUtilIntervalTree_$Lambda$2 : NSObject < JavaUtilFunctionFunction >

- (id)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg;

@end

J2OBJC_STATIC_INIT(EduStanfordNlpUtilIntervalTree_$Lambda$2)

inline EduStanfordNlpUtilIntervalTree_$Lambda$2 *EduStanfordNlpUtilIntervalTree_$Lambda$2_get_instance();
static EduStanfordNlpUtilIntervalTree_$Lambda$2 *EduStanfordNlpUtilIntervalTree_$Lambda$2_instance;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpUtilIntervalTree_$Lambda$2, instance, EduStanfordNlpUtilIntervalTree_$Lambda$2 *)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_$Lambda$2_init(EduStanfordNlpUtilIntervalTree_$Lambda$2 *self);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_$Lambda$2 *new_EduStanfordNlpUtilIntervalTree_$Lambda$2_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_$Lambda$2 *create_EduStanfordNlpUtilIntervalTree_$Lambda$2_init();

@interface EduStanfordNlpUtilIntervalTree_$Lambda$3 : NSObject < JavaUtilFunctionFunction >

- (id)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg;

@end

J2OBJC_STATIC_INIT(EduStanfordNlpUtilIntervalTree_$Lambda$3)

inline EduStanfordNlpUtilIntervalTree_$Lambda$3 *EduStanfordNlpUtilIntervalTree_$Lambda$3_get_instance();
static EduStanfordNlpUtilIntervalTree_$Lambda$3 *EduStanfordNlpUtilIntervalTree_$Lambda$3_instance;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduStanfordNlpUtilIntervalTree_$Lambda$3, instance, EduStanfordNlpUtilIntervalTree_$Lambda$3 *)

__attribute__((unused)) static void EduStanfordNlpUtilIntervalTree_$Lambda$3_init(EduStanfordNlpUtilIntervalTree_$Lambda$3 *self);

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_$Lambda$3 *new_EduStanfordNlpUtilIntervalTree_$Lambda$3_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static EduStanfordNlpUtilIntervalTree_$Lambda$3 *create_EduStanfordNlpUtilIntervalTree_$Lambda$3_init();

@implementation EduStanfordNlpUtilIntervalTree

- (jboolean)isEmpty {
  return [((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(root_)) isEmpty];
}

- (void)clear {
  [((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(root_)) clear];
}

- (NSString *)description {
  return JreStrcat("$I", @"Size: ", ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(root_))->size_);
}

- (jboolean)addWithId:(id<EduStanfordNlpUtilHasInterval>)target {
  return [self addWithEduStanfordNlpUtilIntervalTree_TreeNode:root_ withEduStanfordNlpUtilHasInterval:target withDouble:EduStanfordNlpUtilIntervalTree_defaultAlpha];
}

- (jboolean)addWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                         withEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  return [self addWithEduStanfordNlpUtilIntervalTree_TreeNode:node withEduStanfordNlpUtilHasInterval:target withDouble:EduStanfordNlpUtilIntervalTree_defaultAlpha];
}

- (jboolean)addWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                         withEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target
                                                withDouble:(jdouble)alpha {
  if (target == nil) return false;
  EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
  jint depth = 0;
  jint thresholdDepth = (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node))->size_ > 10) ? (JreFpToInt((-JavaLangMath_logWithDouble_(node->size_) / JavaLangMath_logWithDouble_(alpha) + 1))) : 10;
  while (n != nil) {
    if (n->value_ == nil) {
      n->value_ = target;
      n->maxEnd_ = ((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([target getInterval])) getEnd]);
      n->size_ = 1;
      if (depth > thresholdDepth) {
        EduStanfordNlpUtilIntervalTree_TreeNode *p = n->parent_;
        while (p != nil) {
          if (p->size_ > 10 && ![self isAlphaBalancedWithEduStanfordNlpUtilIntervalTree_TreeNode:p withDouble:alpha]) {
            EduStanfordNlpUtilIntervalTree_TreeNode *newParent = [self balanceWithEduStanfordNlpUtilIntervalTree_TreeNode:p];
            if (p == root_) root_ = newParent;
            break;
          }
          p = p->parent_;
        }
      }
      return true;
    }
    else {
      depth++;
      n->maxEnd_ = ((id<JavaLangComparable>) EduStanfordNlpUtilInterval_maxWithJavaLangComparable_withJavaLangComparable_(((id<JavaLangComparable>) n->maxEnd_), ((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([target getInterval])) getEnd])));
      n->size_++;
      if ([((EduStanfordNlpUtilInterval *) nil_chk([target getInterval])) compareToWithId:[((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval]] <= 0) {
        if (n->left_ == nil) {
          n->left_ = new_EduStanfordNlpUtilIntervalTree_TreeNode_init();
          n->left_->parent_ = n;
        }
        n = n->left_;
      }
      else {
        if (n->right_ == nil) {
          n->right_ = new_EduStanfordNlpUtilIntervalTree_TreeNode_init();
          n->right_->parent_ = n;
        }
        n = n->right_;
      }
    }
  }
  return false;
}

- (jint)size {
  return ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(root_))->size_;
}

- (id<JavaUtilIterator>)iterator {
  return new_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(root_);
}

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c {
  jboolean modified = false;
  for (id __strong t in nil_chk(c)) {
    if ([self removeWithId:t]) {
      modified = true;
    }
  }
  return modified;
}

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"retainAll not implemented");
}

- (jboolean)containsWithId:(id)o {
  @try {
    return [self containsWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>) cast_check(o, EduStanfordNlpUtilHasInterval_class_())];
  }
  @catch (JavaLangClassCastException *ex) {
    return false;
  }
}

- (jboolean)removeWithId:(id)o {
  @try {
    return [self removeWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>) cast_check(o, EduStanfordNlpUtilHasInterval_class_())];
  }
  @catch (JavaLangClassCastException *ex) {
    return false;
  }
}

- (jboolean)removeWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  return [self removeWithEduStanfordNlpUtilIntervalTree_TreeNode:root_ withEduStanfordNlpUtilHasInterval:target];
}

- (jboolean)removeWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                            withEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  if (target == nil) return false;
  if (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node))->value_ == nil) return false;
  if ([target isEqual:node->value_]) {
    jint leftSize = (node->left_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->size_ : 0;
    jint rightSize = (node->right_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->size_ : 0;
    if (leftSize == 0) {
      if (rightSize == 0) {
        [node clear];
      }
      else {
        node->value_ = ((id<EduStanfordNlpUtilHasInterval>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->value_);
        node->size_ = node->right_->size_;
        node->maxEnd_ = ((id<JavaLangComparable>) node->right_->maxEnd_);
        node->left_ = node->right_->left_;
        node->right_ = node->right_->right_;
        if (node->left_ != nil) node->left_->parent_ = node;
        if (node->right_ != nil) node->right_->parent_ = node;
      }
    }
    else if (rightSize == 0) {
      node->value_ = ((id<EduStanfordNlpUtilHasInterval>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->value_);
      node->size_ = node->left_->size_;
      node->maxEnd_ = ((id<JavaLangComparable>) node->left_->maxEnd_);
      node->left_ = node->left_->left_;
      node->right_ = node->left_->right_;
      if (node->left_ != nil) node->left_->parent_ = node;
      if (node->right_ != nil) node->right_->parent_ = node;
    }
    else {
      node->value_ = ((id<EduStanfordNlpUtilHasInterval>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->value_);
      node->size_--;
      node->maxEnd_ = ((id<JavaLangComparable>) EduStanfordNlpUtilInterval_maxWithJavaLangComparable_withJavaLangComparable_(((id<JavaLangComparable>) node->left_->maxEnd_), ((id<JavaLangComparable>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->maxEnd_)));
      EduStanfordNlpUtilIntervalTree_TreeNode *origRight = node->right_;
      node->right_ = ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->right_;
      node->left_ = node->left_->left_;
      if (node->left_ != nil) node->left_->parent_ = node;
      if (node->right_ != nil) node->right_->parent_ = node;
      EduStanfordNlpUtilIntervalTree_TreeNode *rightmost = [self getRightmostNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:node];
      ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(rightmost))->right_ = origRight;
      if (rightmost->right_ != nil) {
        rightmost->right_->parent_ = rightmost;
        EduStanfordNlpUtilIntervalTree_adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilIntervalTree_TreeNode_(self, rightmost->right_, node);
      }
    }
    return true;
  }
  else {
    if ([((EduStanfordNlpUtilInterval *) nil_chk([target getInterval])) compareToWithId:[((id<EduStanfordNlpUtilHasInterval>) nil_chk(node->value_)) getInterval]] <= 0) {
      if (node->left_ == nil) {
        return false;
      }
      jboolean res = [self removeWithEduStanfordNlpUtilIntervalTree_TreeNode:node->left_ withEduStanfordNlpUtilHasInterval:target];
      if (res) {
        node->maxEnd_ = ((id<JavaLangComparable>) EduStanfordNlpUtilInterval_maxWithJavaLangComparable_withJavaLangComparable_(((id<JavaLangComparable>) node->maxEnd_), ((id<JavaLangComparable>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->maxEnd_)));
        node->size_--;
      }
      return res;
    }
    else {
      if (node->right_ == nil) {
        return false;
      }
      jboolean res = [self removeWithEduStanfordNlpUtilIntervalTree_TreeNode:node->right_ withEduStanfordNlpUtilHasInterval:target];
      if (res) {
        node->maxEnd_ = ((id<JavaLangComparable>) EduStanfordNlpUtilInterval_maxWithJavaLangComparable_withJavaLangComparable_(((id<JavaLangComparable>) node->maxEnd_), ((id<JavaLangComparable>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->maxEnd_)));
        node->size_--;
      }
      return res;
    }
  }
}

- (void)adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  EduStanfordNlpUtilIntervalTree_adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilIntervalTree_TreeNode_(self, node, nil);
}

- (void)adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                     withEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)stopAt {
  EduStanfordNlpUtilIntervalTree_adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilIntervalTree_TreeNode_(self, node, stopAt);
}

- (void)adjustWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  EduStanfordNlpUtilIntervalTree_adjustWithEduStanfordNlpUtilIntervalTree_TreeNode_(self, node);
}

- (void)check {
  [self checkWithEduStanfordNlpUtilIntervalTree_TreeNode:root_];
}

- (void)checkWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)treeNode {
  JavaUtilStack *todo = new_JavaUtilStack_init();
  [todo addWithId:treeNode];
  while (![todo isEmpty]) {
    EduStanfordNlpUtilIntervalTree_TreeNode *node = [todo pop];
    if (node == ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node))->parent_) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"node is same as parent!!!");
    }
    if ([node isEmpty]) {
      if (node->left_ != nil) @throw new_JavaLangIllegalStateException_initWithNSString_(@"Empty node shouldn't have left branch");
      if (node->right_ != nil) @throw new_JavaLangIllegalStateException_initWithNSString_(@"Empty node shouldn't have right branch");
      continue;
    }
    jint leftSize = (node->left_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->size_ : 0;
    jint rightSize = (node->right_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->size_ : 0;
    id<JavaLangComparable> leftMax = (node->left_ != nil) ? ((id<JavaLangComparable>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->maxEnd_) : nil;
    id<JavaLangComparable> rightMax = (node->right_ != nil) ? ((id<JavaLangComparable>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->maxEnd_) : nil;
    id<JavaLangComparable> maxEnd = ((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(node->value_)) getInterval])) getEnd]);
    if (leftMax != nil && [leftMax compareToWithId:maxEnd] > 0) {
      maxEnd = leftMax;
    }
    if (rightMax != nil && [rightMax compareToWithId:maxEnd] > 0) {
      maxEnd = rightMax;
    }
    if (![((id<JavaLangComparable>) nil_chk(maxEnd)) isEqual:node->maxEnd_]) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"max end is not as expected!!!");
    }
    if (node->size_ != leftSize + rightSize + 1) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"node size is not one plus the sum of left and right!!!");
    }
    if (node->left_ != nil) {
      if (node->left_->parent_ != node) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"node left parent is not same as node!!!");
      }
    }
    if (node->right_ != nil) {
      if (node->right_->parent_ != node) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"node right parent is not same as node!!!");
      }
    }
    if (node->parent_ != nil) {
      EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
      while (n != nil && n->parent_ != nil) {
        if (n == n->parent_->left_) {
          if (node->value_ != nil) {
            if ([((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) node->value_) getInterval])) compareToWithId:[((id<EduStanfordNlpUtilHasInterval>) nil_chk(((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n->parent_))->value_)) getInterval]] > 0) {
              @throw new_JavaLangIllegalStateException_initWithNSString_(@"node is not on the correct side!!!");
            }
          }
        }
        else if (n == n->parent_->right_) {
          if ([((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(node->value_)) getInterval])) compareToWithId:[((id<EduStanfordNlpUtilHasInterval>) nil_chk(((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n->parent_))->value_)) getInterval]] <= 0) {
            @throw new_JavaLangIllegalStateException_initWithNSString_(@"node is not on the correct side!!!");
          }
        }
        else {
          @throw new_JavaLangIllegalStateException_initWithNSString_(@"node is not parent's left or right child!!!");
        }
        n = n->parent_;
      }
    }
    if (node->left_ != nil) [todo addWithId:node->left_];
    if (node->right_ != nil) [todo addWithId:node->right_];
  }
}

- (jboolean)isAlphaBalancedWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                                                            withDouble:(jdouble)alpha {
  jint leftSize = (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node))->left_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->left_))->size_ : 0;
  jint rightSize = (node->right_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node->right_))->size_ : 0;
  jint threshold = JreFpToInt((alpha * node->size_)) + 1;
  return (leftSize <= threshold) && (rightSize <= threshold);
}

- (void)balance {
  root_ = [self balanceWithEduStanfordNlpUtilIntervalTree_TreeNode:root_];
}

- (EduStanfordNlpUtilIntervalTree_TreeNode *)balanceWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  JavaUtilStack *todo = new_JavaUtilStack_init();
  [todo addWithId:node];
  EduStanfordNlpUtilIntervalTree_TreeNode *newRoot = nil;
  while (![todo isEmpty]) {
    EduStanfordNlpUtilIntervalTree_TreeNode *n = [todo pop];
    jint medianAt = ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n))->size_ / 2;
    EduStanfordNlpUtilIntervalTree_TreeNode *median = [self getNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:n withInt:medianAt];
    if (median != nil && median != n) {
      [self rotateUpWithEduStanfordNlpUtilIntervalTree_TreeNode:median withEduStanfordNlpUtilIntervalTree_TreeNode:n];
    }
    if (newRoot == nil) {
      newRoot = median;
    }
    if (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(median))->left_ != nil) (void) [todo pushWithId:median->left_];
    if (median->right_ != nil) (void) [todo pushWithId:median->right_];
  }
  if (newRoot == nil) return node;
  else return newRoot;
}

- (void)rotateUpWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                withEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)target {
  EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
  jboolean done = false;
  while (n != nil && n->parent_ != nil && !done) {
    done = (n->parent_ == target);
    if (n == n->parent_->left_) {
      n = [self rightRotateWithEduStanfordNlpUtilIntervalTree_TreeNode:n->parent_];
    }
    else if (n == n->parent_->right_) {
      n = [self leftRotateWithEduStanfordNlpUtilIntervalTree_TreeNode:n->parent_];
    }
    else {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Not on parent's left or right branches.");
    }
  }
}

- (EduStanfordNlpUtilIntervalTree_TreeNode *)rightRotateWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)oldRoot {
  if (oldRoot == nil || [oldRoot isEmpty] || oldRoot->left_ == nil) return oldRoot;
  EduStanfordNlpUtilIntervalTree_TreeNode *oldLeftRight = oldRoot->left_->right_;
  EduStanfordNlpUtilIntervalTree_TreeNode *newRoot = oldRoot->left_;
  newRoot->right_ = oldRoot;
  oldRoot->left_ = oldLeftRight;
  newRoot->parent_ = oldRoot->parent_;
  newRoot->maxEnd_ = ((id<JavaLangComparable>) oldRoot->maxEnd_);
  newRoot->size_ = oldRoot->size_;
  if (newRoot->parent_ != nil) {
    if (newRoot->parent_->left_ == oldRoot) {
      newRoot->parent_->left_ = newRoot;
    }
    else if (newRoot->parent_->right_ == oldRoot) {
      newRoot->parent_->right_ = newRoot;
    }
    else {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Old root not a child of it's parent");
    }
  }
  oldRoot->parent_ = newRoot;
  if (oldLeftRight != nil) oldLeftRight->parent_ = oldRoot;
  EduStanfordNlpUtilIntervalTree_adjustWithEduStanfordNlpUtilIntervalTree_TreeNode_(self, oldRoot);
  return newRoot;
}

- (EduStanfordNlpUtilIntervalTree_TreeNode *)leftRotateWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)oldRoot {
  if (oldRoot == nil || [oldRoot isEmpty] || oldRoot->right_ == nil) return oldRoot;
  EduStanfordNlpUtilIntervalTree_TreeNode *oldRightLeft = oldRoot->right_->left_;
  EduStanfordNlpUtilIntervalTree_TreeNode *newRoot = oldRoot->right_;
  newRoot->left_ = oldRoot;
  oldRoot->right_ = oldRightLeft;
  newRoot->parent_ = oldRoot->parent_;
  newRoot->maxEnd_ = ((id<JavaLangComparable>) oldRoot->maxEnd_);
  newRoot->size_ = oldRoot->size_;
  if (newRoot->parent_ != nil) {
    if (newRoot->parent_->left_ == oldRoot) {
      newRoot->parent_->left_ = newRoot;
    }
    else if (newRoot->parent_->right_ == oldRoot) {
      newRoot->parent_->right_ = newRoot;
    }
    else {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Old root not a child of it's parent");
    }
  }
  oldRoot->parent_ = newRoot;
  if (oldRightLeft != nil) oldRightLeft->parent_ = oldRoot;
  EduStanfordNlpUtilIntervalTree_adjustWithEduStanfordNlpUtilIntervalTree_TreeNode_(self, oldRoot);
  return newRoot;
}

- (jint)height {
  return [self heightWithEduStanfordNlpUtilIntervalTree_TreeNode:root_];
}

- (jint)heightWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  if (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node))->value_ == nil) return 0;
  jint lh = (node->left_ != nil) ? [self heightWithEduStanfordNlpUtilIntervalTree_TreeNode:node->left_] : 0;
  jint rh = (node->right_ != nil) ? [self heightWithEduStanfordNlpUtilIntervalTree_TreeNode:node->right_] : 0;
  return JavaLangMath_maxWithInt_withInt_(lh, rh) + 1;
}

- (EduStanfordNlpUtilIntervalTree_TreeNode *)getLeftmostNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
  while (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n))->left_ != nil) {
    n = n->left_;
  }
  return n;
}

- (EduStanfordNlpUtilIntervalTree_TreeNode *)getRightmostNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
  while (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n))->right_ != nil) {
    n = n->right_;
  }
  return n;
}

- (EduStanfordNlpUtilIntervalTree_TreeNode *)getNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                                                                                        withInt:(jint)nodeIndex {
  jint i = nodeIndex;
  EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
  while (n != nil) {
    if (i < 0 || i >= n->size_) return nil;
    jint leftSize = (n->left_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n->left_))->size_ : 0;
    if (i == leftSize) {
      return n;
    }
    else if (i > leftSize) {
      n = n->right_;
      i = i - leftSize - 1;
    }
    else {
      n = n->left_;
    }
  }
  return nil;
}

- (jboolean)addNonOverlappingWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  if ([self overlapsWithEduStanfordNlpUtilHasInterval:target]) return false;
  [self addWithId:target];
  return true;
}

- (jboolean)addNonNestedWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  if ([self containsIntervalWithEduStanfordNlpUtilHasInterval:target withBoolean:false]) return false;
  [self addWithId:target];
  return true;
}

- (jboolean)overlapsWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  return EduStanfordNlpUtilIntervalTree_overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(root_, [((id<EduStanfordNlpUtilHasInterval>) nil_chk(target)) getInterval]);
}

- (id<JavaUtilList>)getOverlappingWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  return EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(root_, [((id<EduStanfordNlpUtilHasInterval>) nil_chk(target)) getInterval]);
}

+ (id<JavaUtilList>)getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)n
                                                       withJavaLangComparable:(id<JavaLangComparable>)p {
  return EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_(n, p);
}

+ (id<JavaUtilList>)getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)n
                                               withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target {
  return EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(n, target);
}

+ (void)getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)n
                                           withJavaLangComparable:(id<JavaLangComparable>)p
                                                 withJavaUtilList:(id<JavaUtilList>)result {
  EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_withJavaUtilList_(n, p, result);
}

+ (void)getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                                   withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                                                 withJavaUtilList:(id<JavaUtilList>)result {
  EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilList_(node, target, result);
}

+ (jboolean)overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)n
                                         withJavaLangComparable:(id<JavaLangComparable>)p {
  return EduStanfordNlpUtilIntervalTree_overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_(n, p);
}

+ (jboolean)overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                                 withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target {
  return EduStanfordNlpUtilIntervalTree_overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(node, target);
}

- (jboolean)containsWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  return EduStanfordNlpUtilIntervalTree_containsValueWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilHasInterval_(self, target);
}

- (jboolean)containsIntervalWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target
                                                  withBoolean:(jboolean)exact {
  return EduStanfordNlpUtilIntervalTree_containsIntervalWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withBoolean_(self, [((id<EduStanfordNlpUtilHasInterval>) nil_chk(target)) getInterval], exact);
}

+ (jboolean)containsIntervalWithEduStanfordNlpUtilIntervalTree:(EduStanfordNlpUtilIntervalTree *)n
                                        withJavaLangComparable:(id<JavaLangComparable>)p
                                                   withBoolean:(jboolean)exact {
  return EduStanfordNlpUtilIntervalTree_containsIntervalWithEduStanfordNlpUtilIntervalTree_withJavaLangComparable_withBoolean_(n, p, exact);
}

+ (jboolean)containsIntervalWithEduStanfordNlpUtilIntervalTree:(EduStanfordNlpUtilIntervalTree *)node
                                withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                                                   withBoolean:(jboolean)exact {
  return EduStanfordNlpUtilIntervalTree_containsIntervalWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withBoolean_(node, target, exact);
}

+ (jboolean)containsValueWithEduStanfordNlpUtilIntervalTree:(EduStanfordNlpUtilIntervalTree *)node
                          withEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  return EduStanfordNlpUtilIntervalTree_containsValueWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilHasInterval_(node, target);
}

+ (jboolean)containsWithEduStanfordNlpUtilIntervalTree:(EduStanfordNlpUtilIntervalTree *)tree
                        withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                          withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)containsTargetFunction {
  return EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(tree, target, containsTargetFunction);
}

+ (jboolean)containsWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node
                                 withEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                                   withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)containsTargetFunction {
  return EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(node, target, containsTargetFunction);
}

+ (id<JavaUtilList>)getNonOverlappingWithJavaUtilList:(id<JavaUtilList>)items
                         withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)toIntervalFunc {
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_(items, toIntervalFunc);
}

+ (id<JavaUtilList>)getNonOverlappingWithJavaUtilList:(id<JavaUtilList>)items
                         withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)toIntervalFunc
                               withJavaUtilComparator:(id<JavaUtilComparator>)compareFunc {
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(items, toIntervalFunc, compareFunc);
}

+ (id<JavaUtilList>)getNonOverlappingWithJavaUtilList:(id<JavaUtilList>)items
                               withJavaUtilComparator:(id<JavaUtilComparator>)compareFunc {
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilComparator_(items, compareFunc);
}

+ (id<JavaUtilList>)getNonOverlappingWithJavaUtilList:(id<JavaUtilList>)items {
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_(items);
}

+ (id<JavaUtilList>)getNonOverlappingMaxScoreWithJavaUtilList:(id<JavaUtilList>)items
                                 withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)toIntervalFunc
                                 withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)scoreFunc {
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingMaxScoreWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilFunctionFunction_(items, toIntervalFunc, scoreFunc);
}

+ (id<JavaUtilList>)getNonOverlappingMaxScoreWithJavaUtilList:(id<JavaUtilList>)items
                                 withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)scoreFunc {
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingMaxScoreWithJavaUtilList_withJavaUtilFunctionFunction_(items, scoreFunc);
}

+ (id<JavaUtilList>)getNonNestedWithJavaUtilList:(id<JavaUtilList>)items
                    withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)toIntervalFunc
                          withJavaUtilComparator:(id<JavaUtilComparator>)compareFunc {
  return EduStanfordNlpUtilIntervalTree_getNonNestedWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(items, toIntervalFunc, compareFunc);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpUtilIntervalTree_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, 3, -1, -1 },
    { NULL, "Z", 0x1, 1, 4, -1, 5, -1, -1 },
    { NULL, "Z", 0x1, 1, 6, -1, 7, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilIterator;", 0x1, -1, -1, -1, 8, -1, -1 },
    { NULL, "Z", 0x1, 9, 10, -1, 11, -1, -1 },
    { NULL, "Z", 0x1, 12, 10, -1, 11, -1, -1 },
    { NULL, "Z", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 2, -1, 3, -1, -1 },
    { NULL, "Z", 0x1, 15, 4, -1, 5, -1, -1 },
    { NULL, "V", 0x2, 16, 17, -1, 18, -1, -1 },
    { NULL, "V", 0x2, 16, 19, -1, 20, -1, -1 },
    { NULL, "V", 0x2, 21, 17, -1, 18, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 22, 17, -1, 18, -1, -1 },
    { NULL, "Z", 0x1, 23, 24, -1, 25, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpUtilIntervalTree_TreeNode;", 0x1, 26, 17, -1, 27, -1, -1 },
    { NULL, "V", 0x1, 28, 19, -1, 20, -1, -1 },
    { NULL, "LEduStanfordNlpUtilIntervalTree_TreeNode;", 0x1, 29, 17, -1, 27, -1, -1 },
    { NULL, "LEduStanfordNlpUtilIntervalTree_TreeNode;", 0x1, 30, 17, -1, 27, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 31, 17, -1, 32, -1, -1 },
    { NULL, "LEduStanfordNlpUtilIntervalTree_TreeNode;", 0x1, 33, 17, -1, 27, -1, -1 },
    { NULL, "LEduStanfordNlpUtilIntervalTree_TreeNode;", 0x1, 34, 17, -1, 27, -1, -1 },
    { NULL, "LEduStanfordNlpUtilIntervalTree_TreeNode;", 0x1, 35, 36, -1, 37, -1, -1 },
    { NULL, "Z", 0x1, 38, 2, -1, 3, -1, -1 },
    { NULL, "Z", 0x1, 39, 2, -1, 3, -1, -1 },
    { NULL, "Z", 0x1, 40, 2, -1, 3, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, 41, 2, -1, 42, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 41, 43, -1, 44, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 41, 45, -1, 46, -1, -1 },
    { NULL, "V", 0x9, 41, 47, -1, 48, -1, -1 },
    { NULL, "V", 0x9, 41, 49, -1, 50, -1, -1 },
    { NULL, "Z", 0x9, 40, 43, -1, 51, -1, -1 },
    { NULL, "Z", 0x9, 40, 45, -1, 52, -1, -1 },
    { NULL, "Z", 0x1, 13, 2, -1, 3, -1, -1 },
    { NULL, "Z", 0x1, 53, 54, -1, 55, -1, -1 },
    { NULL, "Z", 0x9, 53, 56, -1, 57, -1, -1 },
    { NULL, "Z", 0x9, 53, 58, -1, 59, -1, -1 },
    { NULL, "Z", 0x9, 60, 61, -1, 62, -1, -1 },
    { NULL, "Z", 0xa, 13, 63, -1, 64, -1, -1 },
    { NULL, "Z", 0xa, 13, 65, -1, 66, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 67, 68, -1, 69, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 67, 70, -1, 71, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 67, 72, -1, 73, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 67, 74, -1, 75, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 76, 77, -1, 78, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 76, 68, -1, 79, -1, -1 },
    { NULL, "LJavaUtilList;", 0x9, 80, 70, -1, 71, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(isEmpty);
  methods[1].selector = @selector(clear);
  methods[2].selector = @selector(description);
  methods[3].selector = @selector(addWithId:);
  methods[4].selector = @selector(addWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilHasInterval:);
  methods[5].selector = @selector(addWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilHasInterval:withDouble:);
  methods[6].selector = @selector(size);
  methods[7].selector = @selector(iterator);
  methods[8].selector = @selector(removeAllWithJavaUtilCollection:);
  methods[9].selector = @selector(retainAllWithJavaUtilCollection:);
  methods[10].selector = @selector(containsWithId:);
  methods[11].selector = @selector(removeWithId:);
  methods[12].selector = @selector(removeWithEduStanfordNlpUtilHasInterval:);
  methods[13].selector = @selector(removeWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilHasInterval:);
  methods[14].selector = @selector(adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[15].selector = @selector(adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[16].selector = @selector(adjustWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[17].selector = @selector(check);
  methods[18].selector = @selector(checkWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[19].selector = @selector(isAlphaBalancedWithEduStanfordNlpUtilIntervalTree_TreeNode:withDouble:);
  methods[20].selector = @selector(balance);
  methods[21].selector = @selector(balanceWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[22].selector = @selector(rotateUpWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[23].selector = @selector(rightRotateWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[24].selector = @selector(leftRotateWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[25].selector = @selector(height);
  methods[26].selector = @selector(heightWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[27].selector = @selector(getLeftmostNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[28].selector = @selector(getRightmostNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[29].selector = @selector(getNodeWithEduStanfordNlpUtilIntervalTree_TreeNode:withInt:);
  methods[30].selector = @selector(addNonOverlappingWithEduStanfordNlpUtilHasInterval:);
  methods[31].selector = @selector(addNonNestedWithEduStanfordNlpUtilHasInterval:);
  methods[32].selector = @selector(overlapsWithEduStanfordNlpUtilHasInterval:);
  methods[33].selector = @selector(getOverlappingWithEduStanfordNlpUtilHasInterval:);
  methods[34].selector = @selector(getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:withJavaLangComparable:);
  methods[35].selector = @selector(getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilInterval:);
  methods[36].selector = @selector(getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:withJavaLangComparable:withJavaUtilList:);
  methods[37].selector = @selector(getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilInterval:withJavaUtilList:);
  methods[38].selector = @selector(overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode:withJavaLangComparable:);
  methods[39].selector = @selector(overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilInterval:);
  methods[40].selector = @selector(containsWithEduStanfordNlpUtilHasInterval:);
  methods[41].selector = @selector(containsIntervalWithEduStanfordNlpUtilHasInterval:withBoolean:);
  methods[42].selector = @selector(containsIntervalWithEduStanfordNlpUtilIntervalTree:withJavaLangComparable:withBoolean:);
  methods[43].selector = @selector(containsIntervalWithEduStanfordNlpUtilIntervalTree:withEduStanfordNlpUtilInterval:withBoolean:);
  methods[44].selector = @selector(containsValueWithEduStanfordNlpUtilIntervalTree:withEduStanfordNlpUtilHasInterval:);
  methods[45].selector = @selector(containsWithEduStanfordNlpUtilIntervalTree:withEduStanfordNlpUtilInterval:withJavaUtilFunctionFunction:);
  methods[46].selector = @selector(containsWithEduStanfordNlpUtilIntervalTree_TreeNode:withEduStanfordNlpUtilInterval:withJavaUtilFunctionFunction:);
  methods[47].selector = @selector(getNonOverlappingWithJavaUtilList:withJavaUtilFunctionFunction:);
  methods[48].selector = @selector(getNonOverlappingWithJavaUtilList:withJavaUtilFunctionFunction:withJavaUtilComparator:);
  methods[49].selector = @selector(getNonOverlappingWithJavaUtilList:withJavaUtilComparator:);
  methods[50].selector = @selector(getNonOverlappingWithJavaUtilList:);
  methods[51].selector = @selector(getNonOverlappingMaxScoreWithJavaUtilList:withJavaUtilFunctionFunction:withJavaUtilFunctionFunction:);
  methods[52].selector = @selector(getNonOverlappingMaxScoreWithJavaUtilList:withJavaUtilFunctionFunction:);
  methods[53].selector = @selector(getNonNestedWithJavaUtilList:withJavaUtilFunctionFunction:withJavaUtilComparator:);
  methods[54].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "defaultAlpha", "D", .constantValue.asDouble = EduStanfordNlpUtilIntervalTree_defaultAlpha, 0x1a, -1, -1, -1, -1 },
    { "debug", "Z", .constantValue.asBOOL = EduStanfordNlpUtilIntervalTree_debug, 0x1a, -1, -1, -1, -1 },
    { "root_", "LEduStanfordNlpUtilIntervalTree_TreeNode;", .constantValue.asLong = 0, 0x2, -1, -1, 81, -1 },
  };
  static const void *ptrTable[] = { "toString", "add", "LEduStanfordNlpUtilHasInterval;", "(TT;)Z", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilHasInterval;", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;TT;)Z", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilHasInterval;D", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;TT;D)Z", "()Ljava/util/Iterator<TT;>;", "removeAll", "LJavaUtilCollection;", "(Ljava/util/Collection<*>;)Z", "retainAll", "contains", "LNSObject;", "remove", "adjustUpwards", "LEduStanfordNlpUtilIntervalTree_TreeNode;", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;)V", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilIntervalTree_TreeNode;", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;)V", "adjust", "check", "isAlphaBalanced", "LEduStanfordNlpUtilIntervalTree_TreeNode;D", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;D)Z", "balance", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;)Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;", "rotateUp", "rightRotate", "leftRotate", "height", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;)I", "getLeftmostNode", "getRightmostNode", "getNode", "LEduStanfordNlpUtilIntervalTree_TreeNode;I", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;I)Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;", "addNonOverlapping", "addNonNested", "overlaps", "getOverlapping", "(TT;)Ljava/util/List<TT;>;", "LEduStanfordNlpUtilIntervalTree_TreeNode;LJavaLangComparable;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;TE;)Ljava/util/List<TT;>;", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilInterval;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;Ledu/stanford/nlp/util/Interval<TE;>;)Ljava/util/List<TT;>;", "LEduStanfordNlpUtilIntervalTree_TreeNode;LJavaLangComparable;LJavaUtilList;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;TE;Ljava/util/List<TT;>;)V", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilInterval;LJavaUtilList;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;Ledu/stanford/nlp/util/Interval<TE;>;Ljava/util/List<TT;>;)V", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;TE;)Z", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;Ledu/stanford/nlp/util/Interval<TE;>;)Z", "containsInterval", "LEduStanfordNlpUtilHasInterval;Z", "(TT;Z)Z", "LEduStanfordNlpUtilIntervalTree;LJavaLangComparable;Z", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree<TE;TT;>;TE;Z)Z", "LEduStanfordNlpUtilIntervalTree;LEduStanfordNlpUtilInterval;Z", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree<TE;TT;>;Ledu/stanford/nlp/util/Interval<TE;>;Z)Z", "containsValue", "LEduStanfordNlpUtilIntervalTree;LEduStanfordNlpUtilHasInterval;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree<TE;TT;>;TT;)Z", "LEduStanfordNlpUtilIntervalTree;LEduStanfordNlpUtilInterval;LJavaUtilFunctionFunction;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree<TE;TT;>;Ledu/stanford/nlp/util/Interval<TE;>;Ljava/util/function/Function<TT;Ljava/lang/Boolean;>;)Z", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilInterval;LJavaUtilFunctionFunction;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;Ledu/stanford/nlp/util/Interval<TE;>;Ljava/util/function/Function<TT;Ljava/lang/Boolean;>;)Z", "getNonOverlapping", "LJavaUtilList;LJavaUtilFunctionFunction;", "<T:Ljava/lang/Object;E::Ljava/lang/Comparable<TE;>;>(Ljava/util/List<+TT;>;Ljava/util/function/Function<-TT;Ledu/stanford/nlp/util/Interval<TE;>;>;)Ljava/util/List<TT;>;", "LJavaUtilList;LJavaUtilFunctionFunction;LJavaUtilComparator;", "<T:Ljava/lang/Object;E::Ljava/lang/Comparable<TE;>;>(Ljava/util/List<+TT;>;Ljava/util/function/Function<-TT;Ledu/stanford/nlp/util/Interval<TE;>;>;Ljava/util/Comparator<-TT;>;)Ljava/util/List<TT;>;", "LJavaUtilList;LJavaUtilComparator;", "<T::Ledu/stanford/nlp/util/HasInterval<TE;>;E::Ljava/lang/Comparable<TE;>;>(Ljava/util/List<+TT;>;Ljava/util/Comparator<-TT;>;)Ljava/util/List<TT;>;", "LJavaUtilList;", "<T::Ledu/stanford/nlp/util/HasInterval<TE;>;E::Ljava/lang/Comparable<TE;>;>(Ljava/util/List<+TT;>;)Ljava/util/List<TT;>;", "getNonOverlappingMaxScore", "LJavaUtilList;LJavaUtilFunctionFunction;LJavaUtilFunctionFunction;", "<T:Ljava/lang/Object;E::Ljava/lang/Comparable<TE;>;>(Ljava/util/List<+TT;>;Ljava/util/function/Function<-TT;Ledu/stanford/nlp/util/Interval<TE;>;>;Ljava/util/function/Function<-TT;Ljava/lang/Double;>;)Ljava/util/List<TT;>;", "<T::Ledu/stanford/nlp/util/HasInterval<TE;>;E::Ljava/lang/Comparable<TE;>;>(Ljava/util/List<+TT;>;Ljava/util/function/Function<-TT;Ljava/lang/Double;>;)Ljava/util/List<TT;>;", "getNonNested", "Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;", "LEduStanfordNlpUtilIntervalTree_TreeNode;LEduStanfordNlpUtilIntervalTree_TreeNodeIterator;LEduStanfordNlpUtilIntervalTree_ContainsValueFunction;LEduStanfordNlpUtilIntervalTree_ContainsIntervalFunction;LEduStanfordNlpUtilIntervalTree_PartialScoredList;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>Ljava/util/AbstractCollection<TT;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilIntervalTree = { "IntervalTree", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0x1, 55, 3, -1, 82, -1, 83, -1 };
  return &_EduStanfordNlpUtilIntervalTree;
}

@end

void EduStanfordNlpUtilIntervalTree_adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree *self, EduStanfordNlpUtilIntervalTree_TreeNode *node, EduStanfordNlpUtilIntervalTree_TreeNode *stopAt) {
  EduStanfordNlpUtilIntervalTree_TreeNode *n = node;
  while (n != nil && n != stopAt) {
    jint leftSize = (n->left_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n->left_))->size_ : 0;
    jint rightSize = (n->right_ != nil) ? ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(n->right_))->size_ : 0;
    n->maxEnd_ = ((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval])) getEnd]);
    if (n->left_ != nil) {
      n->maxEnd_ = ((id<JavaLangComparable>) EduStanfordNlpUtilInterval_maxWithJavaLangComparable_withJavaLangComparable_(((id<JavaLangComparable>) n->maxEnd_), ((id<JavaLangComparable>) n->left_->maxEnd_)));
    }
    if (n->right_ != nil) {
      n->maxEnd_ = ((id<JavaLangComparable>) EduStanfordNlpUtilInterval_maxWithJavaLangComparable_withJavaLangComparable_(((id<JavaLangComparable>) n->maxEnd_), ((id<JavaLangComparable>) n->right_->maxEnd_)));
    }
    n->size_ = leftSize + 1 + rightSize;
    if (n == n->parent_) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"node is same as parent!!!");
    }
    n = n->parent_;
  }
}

void EduStanfordNlpUtilIntervalTree_adjustWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree *self, EduStanfordNlpUtilIntervalTree_TreeNode *node) {
  EduStanfordNlpUtilIntervalTree_adjustUpwardsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilIntervalTree_TreeNode_(self, node, ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node))->parent_);
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_(EduStanfordNlpUtilIntervalTree_TreeNode *n, id<JavaLangComparable> p) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilList> overlapping = new_JavaUtilArrayList_init();
  EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_withJavaUtilList_(n, p, overlapping);
  return overlapping;
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(EduStanfordNlpUtilIntervalTree_TreeNode *n, EduStanfordNlpUtilInterval *target) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilList> overlapping = new_JavaUtilArrayList_init();
  EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilList_(n, target, overlapping);
  return overlapping;
}

void EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_withJavaUtilList_(EduStanfordNlpUtilIntervalTree_TreeNode *n, id<JavaLangComparable> p, id<JavaUtilList> result) {
  EduStanfordNlpUtilIntervalTree_initialize();
  EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilList_(n, EduStanfordNlpUtilInterval_toIntervalWithJavaLangComparable_withJavaLangComparable_(p, p), result);
}

void EduStanfordNlpUtilIntervalTree_getOverlappingWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilList_(EduStanfordNlpUtilIntervalTree_TreeNode *node, EduStanfordNlpUtilInterval *target, id<JavaUtilList> result) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilQueue> todo = new_JavaUtilLinkedList_init();
  [todo addWithId:node];
  while (![todo isEmpty]) {
    EduStanfordNlpUtilIntervalTree_TreeNode *n = [todo poll];
    if (n == nil || [n isEmpty]) continue;
    if ([((id<JavaLangComparable>) nil_chk(((EduStanfordNlpUtilInterval *) nil_chk(target))->first_)) compareToWithId:((id<JavaLangComparable>) n->maxEnd_)] > 0) continue;
    if (n->left_ != nil) {
      [todo addWithId:n->left_];
    }
    if ([((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval])) overlapsWithEduStanfordNlpUtilInterval:target]) {
      [((id<JavaUtilList>) nil_chk(result)) addWithId:((id<EduStanfordNlpUtilHasInterval>) n->value_)];
    }
    if ([((id<JavaLangComparable>) nil_chk(target->second_)) compareToWithId:((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval])) first])] < 0) {
      continue;
    }
    if (n->right_ != nil) {
      [todo addWithId:n->right_];
    }
  }
}

jboolean EduStanfordNlpUtilIntervalTree_overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode_withJavaLangComparable_(EduStanfordNlpUtilIntervalTree_TreeNode *n, id<JavaLangComparable> p) {
  EduStanfordNlpUtilIntervalTree_initialize();
  return EduStanfordNlpUtilIntervalTree_overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(n, EduStanfordNlpUtilInterval_toIntervalWithJavaLangComparable_withJavaLangComparable_(p, p));
}

jboolean EduStanfordNlpUtilIntervalTree_overlapsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_(EduStanfordNlpUtilIntervalTree_TreeNode *node, EduStanfordNlpUtilInterval *target) {
  EduStanfordNlpUtilIntervalTree_initialize();
  JavaUtilStack *todo = new_JavaUtilStack_init();
  (void) [todo pushWithId:node];
  while (![todo isEmpty]) {
    EduStanfordNlpUtilIntervalTree_TreeNode *n = [todo pop];
    if (n == nil || [n isEmpty]) continue;
    if ([((id<JavaLangComparable>) nil_chk(((EduStanfordNlpUtilInterval *) nil_chk(target))->first_)) compareToWithId:((id<JavaLangComparable>) n->maxEnd_)] > 0) continue;
    if ([((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval])) overlapsWithEduStanfordNlpUtilInterval:target]) {
      return true;
    }
    if (n->left_ != nil) {
      [todo addWithId:n->left_];
    }
    if ([((id<JavaLangComparable>) nil_chk(target->second_)) compareToWithId:((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval])) first])] < 0) {
      continue;
    }
    if (n->right_ != nil) {
      [todo addWithId:n->right_];
    }
  }
  return false;
}

jboolean EduStanfordNlpUtilIntervalTree_containsIntervalWithEduStanfordNlpUtilIntervalTree_withJavaLangComparable_withBoolean_(EduStanfordNlpUtilIntervalTree *n, id<JavaLangComparable> p, jboolean exact) {
  EduStanfordNlpUtilIntervalTree_initialize();
  return EduStanfordNlpUtilIntervalTree_containsIntervalWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withBoolean_(n, EduStanfordNlpUtilInterval_toIntervalWithJavaLangComparable_withJavaLangComparable_(p, p), exact);
}

jboolean EduStanfordNlpUtilIntervalTree_containsIntervalWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilIntervalTree *node, EduStanfordNlpUtilInterval *target, jboolean exact) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilFunctionFunction> containsTargetFunction = new_EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(target, exact);
  return EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(node, [((EduStanfordNlpUtilInterval *) nil_chk(target)) getInterval], containsTargetFunction);
}

jboolean EduStanfordNlpUtilIntervalTree_containsValueWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilHasInterval_(EduStanfordNlpUtilIntervalTree *node, id<EduStanfordNlpUtilHasInterval> target) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilFunctionFunction> containsTargetFunction = new_EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(target);
  return EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(node, [((id<EduStanfordNlpUtilHasInterval>) nil_chk(target)) getInterval], containsTargetFunction);
}

jboolean EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(EduStanfordNlpUtilIntervalTree *tree, EduStanfordNlpUtilInterval *target, id<JavaUtilFunctionFunction> containsTargetFunction) {
  EduStanfordNlpUtilIntervalTree_initialize();
  return EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(((EduStanfordNlpUtilIntervalTree *) nil_chk(tree))->root_, target, containsTargetFunction);
}

jboolean EduStanfordNlpUtilIntervalTree_containsWithEduStanfordNlpUtilIntervalTree_TreeNode_withEduStanfordNlpUtilInterval_withJavaUtilFunctionFunction_(EduStanfordNlpUtilIntervalTree_TreeNode *node, EduStanfordNlpUtilInterval *target, id<JavaUtilFunctionFunction> containsTargetFunction) {
  EduStanfordNlpUtilIntervalTree_initialize();
  JavaUtilStack *todo = new_JavaUtilStack_init();
  (void) [todo pushWithId:node];
  while (![todo isEmpty]) {
    EduStanfordNlpUtilIntervalTree_TreeNode *n = [todo pop];
    if (n == nil || [n isEmpty]) continue;
    if ([((id<JavaLangComparable>) nil_chk(((EduStanfordNlpUtilInterval *) nil_chk(target))->first_)) compareToWithId:((id<JavaLangComparable>) n->maxEnd_)] > 0) {
      continue;
    }
    if ([((JavaLangBoolean *) nil_chk([((id<JavaUtilFunctionFunction>) nil_chk(containsTargetFunction)) applyWithId:((id<EduStanfordNlpUtilHasInterval>) n->value_)])) booleanValue]) return true;
    if (n->left_ != nil) {
      (void) [todo pushWithId:n->left_];
    }
    if ([((id<JavaLangComparable>) nil_chk(target->second_)) compareToWithId:((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(n->value_)) getInterval])) first])] <= 0) {
      continue;
    }
    if (n->right_ != nil) {
      (void) [todo pushWithId:n->right_];
    }
  }
  return false;
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_(id<JavaUtilList> items, id<JavaUtilFunctionFunction> toIntervalFunc) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilList> nonOverlapping = new_JavaUtilArrayList_init();
  EduStanfordNlpUtilIntervalTree *intervals = new_EduStanfordNlpUtilIntervalTree_init();
  for (id __strong item in nil_chk(items)) {
    EduStanfordNlpUtilInterval *i = [((id<JavaUtilFunctionFunction>) nil_chk(toIntervalFunc)) applyWithId:item];
    jboolean addOk = [intervals addNonOverlappingWithEduStanfordNlpUtilHasInterval:i];
    if (addOk) {
      [nonOverlapping addWithId:item];
    }
  }
  return nonOverlapping;
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(id<JavaUtilList> items, id<JavaUtilFunctionFunction> toIntervalFunc, id<JavaUtilComparator> compareFunc) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilList> sorted = new_JavaUtilArrayList_initWithJavaUtilCollection_(items);
  JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(sorted, compareFunc);
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_(sorted, toIntervalFunc);
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilComparator_(id<JavaUtilList> items, id<JavaUtilComparator> compareFunc) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilFunctionFunction> toIntervalFunc = JreLoadStatic(EduStanfordNlpUtilIntervalTree_$Lambda$1, instance);
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(items, toIntervalFunc, compareFunc);
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_(id<JavaUtilList> items) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilFunctionFunction> toIntervalFunc = JreLoadStatic(EduStanfordNlpUtilIntervalTree_$Lambda$2, instance);
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingWithJavaUtilList_withJavaUtilFunctionFunction_(items, toIntervalFunc);
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonOverlappingMaxScoreWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilFunctionFunction_(id<JavaUtilList> items, id<JavaUtilFunctionFunction> toIntervalFunc, id<JavaUtilFunctionFunction> scoreFunc) {
  EduStanfordNlpUtilIntervalTree_initialize();
  if ([((id<JavaUtilList>) nil_chk(items)) size] > 1) {
    id<JavaUtilMap> bestNonOverlapping = new_JavaUtilTreeMap_init();
    for (id __strong item in items) {
      EduStanfordNlpUtilInterval *itemInterval = [((id<JavaUtilFunctionFunction>) nil_chk(toIntervalFunc)) applyWithId:item];
      id<JavaLangComparable> mBegin = ((id<JavaLangComparable>) [((EduStanfordNlpUtilInterval *) nil_chk(itemInterval)) getBegin]);
      id<JavaLangComparable> mEnd = ((id<JavaLangComparable>) [itemInterval getEnd]);
      EduStanfordNlpUtilIntervalTree_PartialScoredList *bestk = [bestNonOverlapping getWithId:mEnd];
      jdouble itemScore = [((JavaLangDouble *) nil_chk([((id<JavaUtilFunctionFunction>) nil_chk(scoreFunc)) applyWithId:item])) doubleValue];
      if (bestk == nil) {
        bestk = new_EduStanfordNlpUtilIntervalTree_PartialScoredList_init();
        bestk->size_ = 1;
        bestk->score_ = itemScore;
        bestk->object_ = item;
        (void) [bestNonOverlapping putWithId:mEnd withId:bestk];
      }
      for (id<JavaLangComparable> __strong j in nil_chk([bestNonOverlapping keySet])) {
        if ([((id<JavaLangComparable>) nil_chk(j)) compareToWithId:mBegin] > 0) break;
        EduStanfordNlpUtilIntervalTree_PartialScoredList *bestj = [bestNonOverlapping getWithId:j];
        jdouble withMatchScore = ((EduStanfordNlpUtilIntervalTree_PartialScoredList *) nil_chk(bestj))->score_ + itemScore;
        jboolean better = false;
        if (withMatchScore > bestk->score_) {
          better = true;
        }
        else if (withMatchScore == bestk->score_) {
          if (bestj->size_ + 1 < bestk->size_) {
            better = true;
          }
        }
        if (better) {
          bestk->size_ = bestj->size_ + 1;
          bestk->score_ = withMatchScore;
          bestk->object_ = item;
          bestk->lastMatchKey_ = j;
        }
      }
    }
    EduStanfordNlpUtilIntervalTree_PartialScoredList *best = nil;
    for (EduStanfordNlpUtilIntervalTree_PartialScoredList * __strong v in nil_chk([bestNonOverlapping values])) {
      if (best == nil || ((EduStanfordNlpUtilIntervalTree_PartialScoredList *) nil_chk(v))->score_ > best->score_) {
        best = v;
      }
    }
    id<JavaUtilList> nonOverlapping = new_JavaUtilArrayList_initWithInt_(((EduStanfordNlpUtilIntervalTree_PartialScoredList *) nil_chk(best))->size_);
    EduStanfordNlpUtilIntervalTree_PartialScoredList *prev = best;
    while (prev != nil) {
      if (prev->object_ != nil) {
        [nonOverlapping addWithId:prev->object_];
      }
      if (prev->lastMatchKey_ != nil) {
        prev = [bestNonOverlapping getWithId:prev->lastMatchKey_];
      }
      else {
        prev = nil;
      }
    }
    JavaUtilCollections_reverseWithJavaUtilList_(nonOverlapping);
    return nonOverlapping;
  }
  else {
    id<JavaUtilList> nonOverlapping = new_JavaUtilArrayList_initWithJavaUtilCollection_(items);
    return nonOverlapping;
  }
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonOverlappingMaxScoreWithJavaUtilList_withJavaUtilFunctionFunction_(id<JavaUtilList> items, id<JavaUtilFunctionFunction> scoreFunc) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilFunctionFunction> toIntervalFunc = JreLoadStatic(EduStanfordNlpUtilIntervalTree_$Lambda$3, instance);
  return EduStanfordNlpUtilIntervalTree_getNonOverlappingMaxScoreWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilFunctionFunction_(items, toIntervalFunc, scoreFunc);
}

id<JavaUtilList> EduStanfordNlpUtilIntervalTree_getNonNestedWithJavaUtilList_withJavaUtilFunctionFunction_withJavaUtilComparator_(id<JavaUtilList> items, id<JavaUtilFunctionFunction> toIntervalFunc, id<JavaUtilComparator> compareFunc) {
  EduStanfordNlpUtilIntervalTree_initialize();
  id<JavaUtilList> sorted = new_JavaUtilArrayList_initWithJavaUtilCollection_(items);
  JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(sorted, compareFunc);
  id<JavaUtilList> res = new_JavaUtilArrayList_init();
  EduStanfordNlpUtilIntervalTree *intervals = new_EduStanfordNlpUtilIntervalTree_init();
  for (id __strong item in sorted) {
    EduStanfordNlpUtilInterval *i = [((id<JavaUtilFunctionFunction>) nil_chk(toIntervalFunc)) applyWithId:item];
    jboolean addOk = [intervals addNonNestedWithEduStanfordNlpUtilHasInterval:i];
    if (addOk) {
      [res addWithId:item];
    }
    else {
    }
  }
  return res;
}

void EduStanfordNlpUtilIntervalTree_init(EduStanfordNlpUtilIntervalTree *self) {
  JavaUtilAbstractCollection_init(self);
  self->root_ = new_EduStanfordNlpUtilIntervalTree_TreeNode_init();
}

EduStanfordNlpUtilIntervalTree *new_EduStanfordNlpUtilIntervalTree_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree, init)
}

EduStanfordNlpUtilIntervalTree *create_EduStanfordNlpUtilIntervalTree_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilIntervalTree)

@implementation EduStanfordNlpUtilIntervalTree_TreeNode

- (jboolean)isEmpty {
  return value_ == nil;
}

- (void)clear {
  value_ = nil;
  maxEnd_ = nil;
  size_ = 0;
  left_ = nil;
  right_ = nil;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpUtilIntervalTree_TreeNode_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(isEmpty);
  methods[1].selector = @selector(clear);
  methods[2].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "value_", "LEduStanfordNlpUtilHasInterval;", .constantValue.asLong = 0, 0x0, -1, -1, 0, -1 },
    { "maxEnd_", "LJavaLangComparable;", .constantValue.asLong = 0, 0x0, -1, -1, 1, -1 },
    { "size_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "left_", "LEduStanfordNlpUtilIntervalTree_TreeNode;", .constantValue.asLong = 0, 0x0, -1, -1, 2, -1 },
    { "right_", "LEduStanfordNlpUtilIntervalTree_TreeNode;", .constantValue.asLong = 0, 0x0, -1, -1, 2, -1 },
    { "parent_", "LEduStanfordNlpUtilIntervalTree_TreeNode;", .constantValue.asLong = 0, 0x0, -1, -1, 2, -1 },
  };
  static const void *ptrTable[] = { "TT;", "TE;", "Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;", "LEduStanfordNlpUtilIntervalTree;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilIntervalTree_TreeNode = { "TreeNode", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0x9, 3, 6, 3, -1, -1, 4, -1 };
  return &_EduStanfordNlpUtilIntervalTree_TreeNode;
}

@end

void EduStanfordNlpUtilIntervalTree_TreeNode_init(EduStanfordNlpUtilIntervalTree_TreeNode *self) {
  NSObject_init(self);
}

EduStanfordNlpUtilIntervalTree_TreeNode *new_EduStanfordNlpUtilIntervalTree_TreeNode_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_TreeNode, init)
}

EduStanfordNlpUtilIntervalTree_TreeNode *create_EduStanfordNlpUtilIntervalTree_TreeNode_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_TreeNode, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilIntervalTree_TreeNode)

@implementation EduStanfordNlpUtilIntervalTree_TreeNodeIterator

- (instancetype)initWithEduStanfordNlpUtilIntervalTree_TreeNode:(EduStanfordNlpUtilIntervalTree_TreeNode *)node {
  EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(self, node);
  return self;
}

- (jboolean)hasNext {
  if (next_ == nil) {
    next_ = EduStanfordNlpUtilIntervalTree_TreeNodeIterator_getNext(self);
  }
  return next_ != nil;
}

- (id<EduStanfordNlpUtilHasInterval>)next {
  if ([self hasNext]) {
    id<EduStanfordNlpUtilHasInterval> x = next_;
    next_ = EduStanfordNlpUtilIntervalTree_TreeNodeIterator_getNext(self);
    return x;
  }
  else @throw new_JavaUtilNoSuchElementException_init();
}

- (id<EduStanfordNlpUtilHasInterval>)getNext {
  return EduStanfordNlpUtilIntervalTree_TreeNodeIterator_getNext(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEduStanfordNlpUtilHasInterval;", 0x1, -1, -1, -1, 2, -1, -1 },
    { NULL, "LEduStanfordNlpUtilHasInterval;", 0x2, -1, -1, -1, 2, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpUtilIntervalTree_TreeNode:);
  methods[1].selector = @selector(hasNext);
  methods[2].selector = @selector(next);
  methods[3].selector = @selector(getNext);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "node_", "LEduStanfordNlpUtilIntervalTree_TreeNode;", .constantValue.asLong = 0, 0x0, -1, -1, 3, -1 },
    { "curIter_", "LJavaUtilIterator;", .constantValue.asLong = 0, 0x0, -1, -1, 4, -1 },
    { "stage_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "next_", "LEduStanfordNlpUtilHasInterval;", .constantValue.asLong = 0, 0x0, -1, -1, 5, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpUtilIntervalTree_TreeNode;", "(Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;)V", "()TT;", "Ledu/stanford/nlp/util/IntervalTree$TreeNode<TE;TT;>;", "Ljava/util/Iterator<TT;>;", "TT;", "LEduStanfordNlpUtilIntervalTree;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>Ledu/stanford/nlp/util/AbstractIterator<TT;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilIntervalTree_TreeNodeIterator = { "TreeNodeIterator", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0xa, 4, 4, 6, -1, -1, 7, -1 };
  return &_EduStanfordNlpUtilIntervalTree_TreeNodeIterator;
}

@end

void EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree_TreeNodeIterator *self, EduStanfordNlpUtilIntervalTree_TreeNode *node) {
  EduStanfordNlpUtilAbstractIterator_init(self);
  self->stage_ = -1;
  self->node_ = node;
  if ([((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(node)) isEmpty]) {
    self->stage_ = 3;
  }
}

EduStanfordNlpUtilIntervalTree_TreeNodeIterator *new_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree_TreeNode *node) {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_TreeNodeIterator, initWithEduStanfordNlpUtilIntervalTree_TreeNode_, node)
}

EduStanfordNlpUtilIntervalTree_TreeNodeIterator *create_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(EduStanfordNlpUtilIntervalTree_TreeNode *node) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_TreeNodeIterator, initWithEduStanfordNlpUtilIntervalTree_TreeNode_, node)
}

id<EduStanfordNlpUtilHasInterval> EduStanfordNlpUtilIntervalTree_TreeNodeIterator_getNext(EduStanfordNlpUtilIntervalTree_TreeNodeIterator *self) {
  if (self->stage_ > 2) return nil;
  while (self->curIter_ == nil || ![self->curIter_ hasNext]) {
    self->stage_++;
    switch (self->stage_) {
      case 0:
      self->curIter_ = (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(self->node_))->left_ != nil) ? new_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(self->node_->left_) : nil;
      break;
      case 1:
      self->curIter_ = nil;
      return ((id<EduStanfordNlpUtilHasInterval>) ((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(self->node_))->value_);
      case 2:
      self->curIter_ = (((EduStanfordNlpUtilIntervalTree_TreeNode *) nil_chk(self->node_))->right_ != nil) ? new_EduStanfordNlpUtilIntervalTree_TreeNodeIterator_initWithEduStanfordNlpUtilIntervalTree_TreeNode_(self->node_->right_) : nil;
      break;
      default:
      return nil;
    }
  }
  if (self->curIter_ != nil && [self->curIter_ hasNext]) {
    return [self->curIter_ next];
  }
  else return nil;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilIntervalTree_TreeNodeIterator)

@implementation EduStanfordNlpUtilIntervalTree_ContainsValueFunction

- (instancetype)initWithEduStanfordNlpUtilHasInterval:(id<EduStanfordNlpUtilHasInterval>)target {
  EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(self, target);
  return self;
}

- (JavaLangBoolean *)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg {
  return JavaLangBoolean_valueOfWithBoolean_([((id<EduStanfordNlpUtilHasInterval>) nil_chk(inArg)) isEqual:target_]);
}

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "LJavaLangBoolean;", 0x1, 2, 0, -1, 3, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpUtilHasInterval:);
  methods[1].selector = @selector(applyWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "target_", "LEduStanfordNlpUtilHasInterval;", .constantValue.asLong = 0, 0x2, -1, -1, 4, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpUtilHasInterval;", "(TT;)V", "apply", "(TT;)Ljava/lang/Boolean;", "TT;", "LEduStanfordNlpUtilIntervalTree;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>Ljava/lang/Object;Ljava/util/function/Function<TT;Ljava/lang/Boolean;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilIntervalTree_ContainsValueFunction = { "ContainsValueFunction", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0xa, 2, 1, 5, -1, -1, 6, -1 };
  return &_EduStanfordNlpUtilIntervalTree_ContainsValueFunction;
}

@end

void EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(EduStanfordNlpUtilIntervalTree_ContainsValueFunction *self, id<EduStanfordNlpUtilHasInterval> target) {
  NSObject_init(self);
  self->target_ = target;
}

EduStanfordNlpUtilIntervalTree_ContainsValueFunction *new_EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(id<EduStanfordNlpUtilHasInterval> target) {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_ContainsValueFunction, initWithEduStanfordNlpUtilHasInterval_, target)
}

EduStanfordNlpUtilIntervalTree_ContainsValueFunction *create_EduStanfordNlpUtilIntervalTree_ContainsValueFunction_initWithEduStanfordNlpUtilHasInterval_(id<EduStanfordNlpUtilHasInterval> target) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_ContainsValueFunction, initWithEduStanfordNlpUtilHasInterval_, target)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilIntervalTree_ContainsValueFunction)

@implementation EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction

- (instancetype)initWithEduStanfordNlpUtilInterval:(EduStanfordNlpUtilInterval *)target
                                       withBoolean:(jboolean)exact {
  EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(self, target, exact);
  return self;
}

- (JavaLangBoolean *)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg {
  if (exact_) {
    return JavaLangBoolean_valueOfWithBoolean_([((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(inArg)) getInterval])) isEqual:target_]);
  }
  else {
    return JavaLangBoolean_valueOfWithBoolean_([((EduStanfordNlpUtilInterval *) nil_chk([((id<EduStanfordNlpUtilHasInterval>) nil_chk(inArg)) getInterval])) containsWithEduStanfordNlpUtilInterval:target_]);
  }
}

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "LJavaLangBoolean;", 0x1, 2, 3, -1, 4, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduStanfordNlpUtilInterval:withBoolean:);
  methods[1].selector = @selector(applyWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "target_", "LEduStanfordNlpUtilInterval;", .constantValue.asLong = 0, 0x2, -1, -1, 5, -1 },
    { "exact_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduStanfordNlpUtilInterval;Z", "(Ledu/stanford/nlp/util/Interval<TE;>;Z)V", "apply", "LEduStanfordNlpUtilHasInterval;", "(TT;)Ljava/lang/Boolean;", "Ledu/stanford/nlp/util/Interval<TE;>;", "LEduStanfordNlpUtilIntervalTree;", "<E::Ljava/lang/Comparable<TE;>;T::Ledu/stanford/nlp/util/HasInterval<TE;>;>Ljava/lang/Object;Ljava/util/function/Function<TT;Ljava/lang/Boolean;>;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction = { "ContainsIntervalFunction", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0xa, 2, 2, 6, -1, -1, 7, -1 };
  return &_EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction;
}

@end

void EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction *self, EduStanfordNlpUtilInterval *target, jboolean exact) {
  NSObject_init(self);
  self->target_ = target;
  self->exact_ = exact;
}

EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction *new_EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilInterval *target, jboolean exact) {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction, initWithEduStanfordNlpUtilInterval_withBoolean_, target, exact)
}

EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction *create_EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction_initWithEduStanfordNlpUtilInterval_withBoolean_(EduStanfordNlpUtilInterval *target, jboolean exact) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction, initWithEduStanfordNlpUtilInterval_withBoolean_, target, exact)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilIntervalTree_ContainsIntervalFunction)

@implementation EduStanfordNlpUtilIntervalTree_PartialScoredList

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  EduStanfordNlpUtilIntervalTree_PartialScoredList_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "object_", "LNSObject;", .constantValue.asLong = 0, 0x0, -1, -1, 0, -1 },
    { "lastMatchKey_", "LNSObject;", .constantValue.asLong = 0, 0x0, -1, -1, 1, -1 },
    { "size_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "score_", "D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "TT;", "TE;", "LEduStanfordNlpUtilIntervalTree;", "<T:Ljava/lang/Object;E:Ljava/lang/Object;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilIntervalTree_PartialScoredList = { "PartialScoredList", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0xa, 1, 4, 2, -1, -1, 3, -1 };
  return &_EduStanfordNlpUtilIntervalTree_PartialScoredList;
}

@end

void EduStanfordNlpUtilIntervalTree_PartialScoredList_init(EduStanfordNlpUtilIntervalTree_PartialScoredList *self) {
  NSObject_init(self);
}

EduStanfordNlpUtilIntervalTree_PartialScoredList *new_EduStanfordNlpUtilIntervalTree_PartialScoredList_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_PartialScoredList, init)
}

EduStanfordNlpUtilIntervalTree_PartialScoredList *create_EduStanfordNlpUtilIntervalTree_PartialScoredList_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_PartialScoredList, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilIntervalTree_PartialScoredList)

J2OBJC_INITIALIZED_DEFN(EduStanfordNlpUtilIntervalTree_$Lambda$1)

@implementation EduStanfordNlpUtilIntervalTree_$Lambda$1

- (id)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg {
  return [((id<EduStanfordNlpUtilHasInterval>) nil_chk(inArg)) getInterval];
}

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (void)initialize {
  if (self == [EduStanfordNlpUtilIntervalTree_$Lambda$1 class]) {
    EduStanfordNlpUtilIntervalTree_$Lambda$1_instance = new_EduStanfordNlpUtilIntervalTree_$Lambda$1_init();
    J2OBJC_SET_INITIALIZED(EduStanfordNlpUtilIntervalTree_$Lambda$1)
  }
}

@end

void EduStanfordNlpUtilIntervalTree_$Lambda$1_init(EduStanfordNlpUtilIntervalTree_$Lambda$1 *self) {
  NSObject_init(self);
}

EduStanfordNlpUtilIntervalTree_$Lambda$1 *new_EduStanfordNlpUtilIntervalTree_$Lambda$1_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_$Lambda$1, init)
}

EduStanfordNlpUtilIntervalTree_$Lambda$1 *create_EduStanfordNlpUtilIntervalTree_$Lambda$1_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_$Lambda$1, init)
}

J2OBJC_INITIALIZED_DEFN(EduStanfordNlpUtilIntervalTree_$Lambda$2)

@implementation EduStanfordNlpUtilIntervalTree_$Lambda$2

- (id)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg {
  return [((id<EduStanfordNlpUtilHasInterval>) nil_chk(inArg)) getInterval];
}

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (void)initialize {
  if (self == [EduStanfordNlpUtilIntervalTree_$Lambda$2 class]) {
    EduStanfordNlpUtilIntervalTree_$Lambda$2_instance = new_EduStanfordNlpUtilIntervalTree_$Lambda$2_init();
    J2OBJC_SET_INITIALIZED(EduStanfordNlpUtilIntervalTree_$Lambda$2)
  }
}

@end

void EduStanfordNlpUtilIntervalTree_$Lambda$2_init(EduStanfordNlpUtilIntervalTree_$Lambda$2 *self) {
  NSObject_init(self);
}

EduStanfordNlpUtilIntervalTree_$Lambda$2 *new_EduStanfordNlpUtilIntervalTree_$Lambda$2_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_$Lambda$2, init)
}

EduStanfordNlpUtilIntervalTree_$Lambda$2 *create_EduStanfordNlpUtilIntervalTree_$Lambda$2_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_$Lambda$2, init)
}

J2OBJC_INITIALIZED_DEFN(EduStanfordNlpUtilIntervalTree_$Lambda$3)

@implementation EduStanfordNlpUtilIntervalTree_$Lambda$3

- (id)applyWithId:(id<EduStanfordNlpUtilHasInterval>)inArg {
  return [((id<EduStanfordNlpUtilHasInterval>) nil_chk(inArg)) getInterval];
}

- (id<JavaUtilFunctionFunction>)andThenWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_andThenWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilFunctionFunction>)composeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilFunctionFunction_composeWithJavaUtilFunctionFunction_(self, arg0);
}

+ (void)initialize {
  if (self == [EduStanfordNlpUtilIntervalTree_$Lambda$3 class]) {
    EduStanfordNlpUtilIntervalTree_$Lambda$3_instance = new_EduStanfordNlpUtilIntervalTree_$Lambda$3_init();
    J2OBJC_SET_INITIALIZED(EduStanfordNlpUtilIntervalTree_$Lambda$3)
  }
}

@end

void EduStanfordNlpUtilIntervalTree_$Lambda$3_init(EduStanfordNlpUtilIntervalTree_$Lambda$3 *self) {
  NSObject_init(self);
}

EduStanfordNlpUtilIntervalTree_$Lambda$3 *new_EduStanfordNlpUtilIntervalTree_$Lambda$3_init() {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilIntervalTree_$Lambda$3, init)
}

EduStanfordNlpUtilIntervalTree_$Lambda$3 *create_EduStanfordNlpUtilIntervalTree_$Lambda$3_init() {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilIntervalTree_$Lambda$3, init)
}
