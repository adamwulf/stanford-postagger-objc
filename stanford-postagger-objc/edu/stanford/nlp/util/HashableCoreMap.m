//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: stanford-postagger-java/edu/stanford/nlp/util/HashableCoreMap.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "edu/stanford/nlp/util/ArrayCoreMap.h"
#include "edu/stanford/nlp/util/HashableCoreMap.h"
#include "java/lang/RuntimeException.h"
#include "java/util/Map.h"
#include "java/util/Set.h"

static id (*EduStanfordNlpUtilHashableCoreMap_super$_setWithIOSClass_withId_)(id, SEL, id, id);

static id (*EduStanfordNlpUtilHashableCoreMap_super$_getWithIOSClass_)(id, SEL, id);

@interface EduStanfordNlpUtilHashableCoreMap () {
 @public
  id<JavaUtilSet> immutableKeys_;
  jint hashcode_;
}

@end

J2OBJC_FIELD_SETTER(EduStanfordNlpUtilHashableCoreMap, immutableKeys_, id<JavaUtilSet>)

inline jlong EduStanfordNlpUtilHashableCoreMap_get_serialVersionUID();
#define EduStanfordNlpUtilHashableCoreMap_serialVersionUID 1LL
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpUtilHashableCoreMap, serialVersionUID, jlong)

inline jlong EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_get_serialVersionUID();
#define EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_serialVersionUID 1LL
J2OBJC_STATIC_FIELD_CONSTANT(EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException, serialVersionUID, jlong)

J2OBJC_INITIALIZED_DEFN(EduStanfordNlpUtilHashableCoreMap)

@implementation EduStanfordNlpUtilHashableCoreMap

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)hashkey {
  EduStanfordNlpUtilHashableCoreMap_initWithJavaUtilMap_(self, hashkey);
  return self;
}

- (instancetype)initWithEduStanfordNlpUtilArrayCoreMap:(EduStanfordNlpUtilArrayCoreMap *)other
                                       withJavaUtilSet:(id<JavaUtilSet>)hashkey {
  EduStanfordNlpUtilHashableCoreMap_initWithEduStanfordNlpUtilArrayCoreMap_withJavaUtilSet_(self, other, hashkey);
  return self;
}

- (id)setWithIOSClass:(IOSClass *)key
               withId:(id)value {
  if ([((id<JavaUtilSet>) nil_chk(immutableKeys_)) containsWithId:key]) {
    @throw new_EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_initWithNSString_(JreStrcat("$$", @"Attempt to change value of immutable field ", [((IOSClass *) nil_chk(key)) getSimpleName]));
  }
  return [super setWithIOSClass:key withId:value];
}

- (NSUInteger)hash {
  return hashcode_;
}

- (jboolean)isEqual:(id)o {
  if ([o isKindOfClass:[EduStanfordNlpUtilHashableCoreMap class]]) {
    EduStanfordNlpUtilHashableCoreMap *other = (EduStanfordNlpUtilHashableCoreMap *) cast_chk(o, [EduStanfordNlpUtilHashableCoreMap class]);
    if (![((id<JavaUtilSet>) nil_chk(((EduStanfordNlpUtilHashableCoreMap *) nil_chk(other))->immutableKeys_)) isEqual:self->immutableKeys_]) {
      return false;
    }
    for (IOSClass * __strong key in immutableKeys_) {
      if (![nil_chk([self getWithIOSClass:key]) isEqual:[other getWithIOSClass:key]]) {
        return false;
      }
    }
    return true;
  }
  else {
    return [super isEqual:o];
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, 3, -1, -1 },
    { NULL, "LNSObject;", 0x1, 4, 5, -1, 6, -1, -1 },
    { NULL, "I", 0x1, 7, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 8, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilMap:);
  methods[1].selector = @selector(initWithEduStanfordNlpUtilArrayCoreMap:withJavaUtilSet:);
  methods[2].selector = @selector(setWithIOSClass:withId:);
  methods[3].selector = @selector(hash);
  methods[4].selector = @selector(isEqual:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "immutableKeys_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x12, -1, -1, 10, -1 },
    { "hashcode_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "serialVersionUID", "J", .constantValue.asLong = EduStanfordNlpUtilHashableCoreMap_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilMap;", "(Ljava/util/Map<Ljava/lang/Class<+Ledu/stanford/nlp/util/TypesafeMap$Key<*>;>;Ljava/lang/Object;>;)V", "LEduStanfordNlpUtilArrayCoreMap;LJavaUtilSet;", "(Ledu/stanford/nlp/util/ArrayCoreMap;Ljava/util/Set<Ljava/lang/Class<+Ledu/stanford/nlp/util/TypesafeMap$Key<*>;>;>;)V", "set", "LIOSClass;LNSObject;", "<VALUE:Ljava/lang/Object;>(Ljava/lang/Class<+Ledu/stanford/nlp/util/TypesafeMap$Key<TVALUE;>;>;TVALUE;)TVALUE;", "hashCode", "equals", "LNSObject;", "Ljava/util/Set<Ljava/lang/Class<+Ledu/stanford/nlp/util/TypesafeMap$Key<*>;>;>;", "LEduStanfordNlpUtilHashableCoreMap_HashableCoreMapException;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilHashableCoreMap = { "HashableCoreMap", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0x1, 5, 3, -1, 11, -1, -1, -1 };
  return &_EduStanfordNlpUtilHashableCoreMap;
}

+ (void)initialize {
  if (self == [EduStanfordNlpUtilHashableCoreMap class]) {
    EduStanfordNlpUtilHashableCoreMap_super$_getWithIOSClass_ = (id (*)(id, SEL, id))[EduStanfordNlpUtilArrayCoreMap instanceMethodForSelector:@selector(getWithIOSClass:)];
    EduStanfordNlpUtilHashableCoreMap_super$_setWithIOSClass_withId_ = (id (*)(id, SEL, id, id))[EduStanfordNlpUtilArrayCoreMap instanceMethodForSelector:@selector(setWithIOSClass:withId:)];
    J2OBJC_SET_INITIALIZED(EduStanfordNlpUtilHashableCoreMap)
  }
}

@end

void EduStanfordNlpUtilHashableCoreMap_initWithJavaUtilMap_(EduStanfordNlpUtilHashableCoreMap *self, id<JavaUtilMap> hashkey) {
  EduStanfordNlpUtilArrayCoreMap_init(self);
  jint keyHashcode = 0;
  jint valueHashcode = 0;
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((id<JavaUtilMap>) nil_chk(hashkey)) entrySet])) {
    keyHashcode += ((jint) [((IOSClass *) nil_chk([((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey])) hash]);
    valueHashcode += ((jint) [nil_chk([entry_ getValue]) hash]);
    (void) EduStanfordNlpUtilHashableCoreMap_super$_setWithIOSClass_withId_(self, @selector(setWithIOSClass:withId:), [entry_ getKey], [entry_ getValue]);
  }
  self->immutableKeys_ = [hashkey keySet];
  self->hashcode_ = keyHashcode * 31 + valueHashcode;
}

EduStanfordNlpUtilHashableCoreMap *new_EduStanfordNlpUtilHashableCoreMap_initWithJavaUtilMap_(id<JavaUtilMap> hashkey) {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilHashableCoreMap, initWithJavaUtilMap_, hashkey)
}

EduStanfordNlpUtilHashableCoreMap *create_EduStanfordNlpUtilHashableCoreMap_initWithJavaUtilMap_(id<JavaUtilMap> hashkey) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilHashableCoreMap, initWithJavaUtilMap_, hashkey)
}

void EduStanfordNlpUtilHashableCoreMap_initWithEduStanfordNlpUtilArrayCoreMap_withJavaUtilSet_(EduStanfordNlpUtilHashableCoreMap *self, EduStanfordNlpUtilArrayCoreMap *other, id<JavaUtilSet> hashkey) {
  EduStanfordNlpUtilArrayCoreMap_initWithEduStanfordNlpUtilArrayCoreMap_(self, other);
  jint keyHashcode = 0;
  jint valueHashcode = 0;
  for (IOSClass * __strong key in nil_chk(hashkey)) {
    keyHashcode += ((jint) [((IOSClass *) nil_chk(key)) hash]);
    valueHashcode += ((jint) [nil_chk(EduStanfordNlpUtilHashableCoreMap_super$_getWithIOSClass_(self, @selector(getWithIOSClass:), key)) hash]);
  }
  self->immutableKeys_ = hashkey;
  self->hashcode_ = keyHashcode * 31 + valueHashcode;
}

EduStanfordNlpUtilHashableCoreMap *new_EduStanfordNlpUtilHashableCoreMap_initWithEduStanfordNlpUtilArrayCoreMap_withJavaUtilSet_(EduStanfordNlpUtilArrayCoreMap *other, id<JavaUtilSet> hashkey) {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilHashableCoreMap, initWithEduStanfordNlpUtilArrayCoreMap_withJavaUtilSet_, other, hashkey)
}

EduStanfordNlpUtilHashableCoreMap *create_EduStanfordNlpUtilHashableCoreMap_initWithEduStanfordNlpUtilArrayCoreMap_withJavaUtilSet_(EduStanfordNlpUtilArrayCoreMap *other, id<JavaUtilSet> hashkey) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilHashableCoreMap, initWithEduStanfordNlpUtilArrayCoreMap_withJavaUtilSet_, other, hashkey)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilHashableCoreMap)

@implementation EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException

- (instancetype)initWithNSString:(NSString *)message {
  EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_initWithNSString_(self, message);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;", "LEduStanfordNlpUtilHashableCoreMap;" };
  static const J2ObjcClassInfo _EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException = { "HashableCoreMapException", "edu.stanford.nlp.util", ptrTable, methods, fields, 7, 0x9, 1, 1, 1, -1, -1, -1, -1 };
  return &_EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException;
}

@end

void EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_initWithNSString_(EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException *self, NSString *message) {
  JavaLangRuntimeException_initWithNSString_(self, message);
}

EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException *new_EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_initWithNSString_(NSString *message) {
  J2OBJC_NEW_IMPL(EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException, initWithNSString_, message)
}

EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException *create_EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException_initWithNSString_(NSString *message) {
  J2OBJC_CREATE_IMPL(EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException, initWithNSString_, message)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduStanfordNlpUtilHashableCoreMap_HashableCoreMapException)
